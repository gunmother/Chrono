<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Chrono</title>

<link rel="manifest" href="manifest.webmanifest">
<meta name="theme-color" content="#000000">

<style>
  :root{
    /* ===== Neumorphic theme ===== */
    --bg:#e3eaf2;
    --ink:#222;

    --icon-inactive:#42586d;
    --icon-active:#27e6f2;
    --pressed-navy:#355169;
    --turq-glow: rgba(39,230,242,.55);

    --off:8px;
    --blur:12px;
    --hi:#ffffff;
    --lo:#b3bfcd;

    --gap:24px;
    --radius:24px;

    /* App tokens preserved */
    --r-lg:12px; --r-pill:999px;
    --border:#bdbdbd; --grid-line:#e1e1e1;
    --chart-bg:#f3f3f3;

    --hour-col:56px;
    --dow-h:32px;
    --label-size:12px;

    --panelW:520px;

    /* Marquee */
    --marquee-border:4px;
    --marquee-shadow:0 0 0 3px rgba(0,0,0,.15), 0 10px 18px rgba(0,0,0,.20);

    /* Handles */
    --handle-height:48px;
    --handle-stroke:#6f6f6f;
  }

  html,body{height:100%;margin:0;background:var(--bg);color:var(--ink);
    font:500 16px/1.4 system-ui,-apple-system,"Segoe UI",Roboto,Arial,sans-serif;overflow:hidden}
  *{box-sizing:border-box}

  /* Frame uses even padding + gap */
  .app{
    width:clamp(320px, 96vw, 520px);
    height:calc(100svh - max(16px, env(safe-area-inset-top)) - max(16px, env(safe-area-inset-bottom)));
    margin:max(16px, env(safe-area-inset-top)) auto;
    display:flex; flex-direction:column; gap:var(--gap); padding:0 var(--gap);
  }

  /* Neumorphic screen panel */
  #screen{
    flex:1; min-height:420px; border-radius:var(--radius); background:var(--bg);
    box-shadow:
      calc(-1*var(--off)) calc(-1*var(--off)) var(--blur) var(--hi),
       var(--off)         var(--off)         var(--blur) var(--lo);
    position:relative; overflow:hidden;
  }

  /* Neumorphic buttons row */
  .controls{ display:flex; gap:var(--gap); padding-bottom:2px; }
  .neu-btn{
    --btn-d: calc((100% - (3 * var(--gap))) / 4);
    flex:0 0 var(--btn-d); width:var(--btn-d); aspect-ratio:1/1;
    border-radius:50%; border:none; outline:none; cursor:pointer;
    background:var(--bg);
    display:grid; place-items:center;
    box-shadow:
      calc(-1*var(--off)) calc(-1*var(--off)) var(--blur) var(--hi),
       var(--off)         var(--off)         var(--blur) var(--lo);
    transition: box-shadow .2s ease, background .2s ease, transform .06s ease;
  }
  .neu-btn svg{ width:44%; height:auto; stroke:var(--icon-inactive); stroke-width:1.9; fill:none; stroke-linecap:round; stroke-linejoin:round; transition:stroke .2s ease, filter .2s ease; }
  .neu-btn.is-pressed{
    background:
      radial-gradient(circle at 82% 82%, rgba(39,230,242,.10) 0%, rgba(39,230,242,.05) 34%, rgba(39,230,242,0) 60%),
      var(--pressed-navy);
    box-shadow:
       var(--off)         var(--off)         var(--blur) var(--hi),
      calc(-1*var(--off)) calc(-1*var(--off)) var(--blur) var(--lo);
  }
  .neu-btn.is-pressed svg{ stroke:var(--icon-active); filter:drop-shadow(0 0 1px var(--turq-glow)) drop-shadow(0 0 6px var(--turq-glow)); }
  .neu-btn:active{ transform:scale(.98); }

  /* Small neu variant (for chevrons + selector pair) */
  .neu-btn--sm{
    width:44px; height:44px; border-radius:12px; flex:0 0 auto;
    display:grid; place-items:center; background:var(--bg); border:none; cursor:pointer;
    box-shadow:
      calc(-1*var(--off)) calc(-1*var(--off)) var(--blur) var(--hi),
       var(--off)         var(--off)         var(--blur) var(--lo);
    transition: box-shadow .2s ease, background .2s ease, transform .06s ease;
  }
  .neu-btn--sm svg{ width:22px; height:22px; stroke:var(--icon-inactive); fill:none; stroke-linecap:round; stroke-linejoin:round; }
  .neu-btn--sm.is-pressed{
    background:
      radial-gradient(circle at 82% 82%, rgba(39,230,242,.10) 0%, rgba(39,230,242,.05) 34%, rgba(39,230,242,0) 60%),
      var(--pressed-navy);
  }
  .neu-btn--sm.is-pressed svg{ stroke:var(--icon-active); filter:drop-shadow(0 0 1px var(--turq-glow)) drop-shadow(0 0 6px var(--turq-glow)); }
  .neu-btn--sm:active{ transform:scale(.98); }

  .wrap{ position:absolute; inset:0; display:grid; grid-template-rows:auto 1fr; min-width:0 }
  .head{ display:grid; grid-template-columns:auto 1fr auto; align-items:center; gap:8px; padding:8px 10px; }
  .title{ text-align:center; font-weight:800; font-size:16px; min-width:0; overflow:hidden; text-overflow:ellipsis; white-space:nowrap }

  .grid-area{ position:relative; overflow:hidden }
  .hours{ position:absolute; top:var(--dow-h); bottom:0; left:0; width:var(--hour-col); pointer-events:none; z-index:0 }
  .hour-stamp{ position:absolute; left:8px; transform:translateY(-50%); font-size:var(--label-size); color:#444; opacity:.95; white-space:nowrap }

  .top-row{ position:absolute; top:0; left:var(--hour-col); right:0; height:var(--dow-h); display:grid; align-items:center; min-width:0 }
  .top-row.week{ grid-template-columns:repeat(7,1fr); column-gap:8px; padding:0 6px }
  .top-row.day{ grid-template-columns:1fr; padding:0 4px }
  .day-pill{ justify-self:center; border:none; padding:0 2px; text-align:center; font-size:clamp(10px, 1.9vw, 12px); background:transparent; color:#000; white-space:nowrap }

  .grid{
    position:absolute; top:var(--dow-h); left:var(--hour-col); right:0; bottom:0;
    background:var(--chart-bg);
    border-left:1px solid var(--grid-line); border-right:1px solid var(--grid-line);
    z-index:0;
  }
  .blocks{ position:absolute; inset:0; z-index:1 }
  .blk{ position:absolute; border:1px solid var(--border) }
  .mask{ position:absolute; inset:0; pointer-events:none; shape-rendering:crispEdges; z-index:2 }
  .now{ position:absolute; border:2px solid #0EA5E9; border-radius:999px; background:rgba(0,0,0,.03); display:none; pointer-events:none; z-index:3 }

  /* Month */
  .month-wrap{ position:absolute; inset:0; display:grid; grid-template-rows:auto auto 1fr }
  .month-dow{ display:grid; grid-template-columns:repeat(7,1fr); padding:6px 10px 0 10px; gap:6px; font-size:12px; letter-spacing:0.05em; color:#444 }
  .month-dow span{ text-align:center }
  .month-grid{ height:100%; display:grid; grid-template-columns:repeat(7,1fr); grid-auto-rows:1fr; gap:6px; padding:10px; }
  .mcell{ border:1px solid var(--grid-line); border-radius:8px; padding:6px; font-size:12px; background:#fff; display:flex; align-items:flex-start; justify-content:flex-start }
  .mcell.today{ outline:2px solid #0EA5E9; outline-offset:1px }
  .mcell.muted{ color:#9c9c9c }

  /* Selection UI */
  .selHost{ position:absolute; inset:0; overflow:visible; pointer-events:none; z-index:1000; }
  .marquee{ position:absolute; pointer-events:none; }
  .marqueeRect{
    position:absolute; box-sizing:border-box; border:var(--marquee-border) solid #fff;
    box-shadow: var(--marquee-shadow);
    border-radius:8px; pointer-events:none;
  }
  .stamp{
    position:absolute; left:50%; transform:translateX(-50%); background:#fff; color:#111;
    border:1px solid var(--border); border-radius:10px; padding:4px 8px; font-size:12px; font-variant-numeric:tabular-nums; font-weight:800; white-space:nowrap; pointer-events:none; z-index:2;
  }
  .handle{ position:absolute; left:0; width:100%; height:var(--handle-height); pointer-events:auto; cursor:ns-resize; z-index:3; touch-action:none; }
  .handle svg{ display:block; width:100%; height:100%; }
  .handle polygon{ fill:#fff; stroke:var(--handle-stroke); stroke-width:2.25; stroke-linejoin:round; }

  .hint{ position:absolute; left:50%; top:calc(var(--dow-h) + 8px); transform:translateX(-50%);
    background:#111; color:#fff; font-size:12px; font-weight:700; padding:6px 10px; border-radius:10px; box-shadow:0 6px 16px rgba(0,0,0,.22);
    opacity:0; transition:opacity .25s ease, transform .25s ease; z-index:50; pointer-events:none; }
  .hint.show{ opacity:1; transform:translateX(-50%) translateY(0); }

  /* Edge confirm */
  .edgeVeil{ position:fixed; inset:0; z-index:1400; background:transparent; pointer-events:auto; }
  .edgeConfirm{
    position:fixed; background:#fff; color:#111; border:1px solid var(--border); border-radius:10px;
    box-shadow:0 10px 24px rgba(0,0,0,.22); padding:8px 10px; z-index:1501; pointer-events:auto;
    font-weight:800; font-size:12px; display:grid; gap:6px; place-items:center; min-width:160px; touch-action:none;
  }
  .edgeRow{ display:flex; gap:12px; }
  .edgeBtn{ min-width:56px; height:36px; padding:0 10px; border-radius:10px; border:1px solid var(--border); background:#fff; font-weight:900; cursor:pointer; }
  .edgeBtn.ok{ background:#e6e6e6; }

  /* Selector floating buttons (week-only) */
  .selBtns{ position:fixed; z-index:1450; display:grid; gap:8px; pointer-events:auto; }
  .selBtn{ composes: neu-btn--sm; } /* (for editors: logical grouping) */

  /* Settings modal */
  .settingsVeil{ position:fixed; inset:0; background:rgba(0,0,0,.25); z-index:1600; }
  .settingsModal{
    position:fixed; left:50%; top:50%; transform:translate(-50%,-50%);
    width:min(92vw, 440px); background:#fff; color:#111; border:1px solid var(--border);
    border-radius:12px; box-shadow:0 16px 40px rgba(0,0,0,.28); z-index:1700; display:grid; grid-template-rows:auto 1fr auto;
  }
  .settingsHead{ padding:12px 14px; border-bottom:1px solid var(--grid-line); font-weight:800; display:flex; justify-content:space-between; align-items:center; }
  .settingsBody{ padding:16px; color:#555; font-size:14px; min-height:140px; }
  .settingsFoot{ padding:10px 14px; border-top:1px solid var(--grid-line); display:flex; justify-content:flex-end; gap:10px; }
  .closeBtn{ border:1px solid var(--border); background:#fff; border-radius:10px; padding:8px 12px; font-weight:800; cursor:pointer; }
  .closeBtn.ok{ background:#e6e6e6; }
</style>
</head>
<body>
  <main class="app">
    <section id="screen" aria-live="polite" aria-label="Content area"></section>

    <nav class="controls" role="group" aria-label="Primary views">
      <!-- Day -->
      <button class="neu-btn" aria-label="Day view" aria-pressed="false" data-view="day" title="Day">
        <svg viewBox="0 0 24 24" aria-hidden="true">
          <circle cx="12" cy="12" r="4"/>
          <line x1="12" y1="2"  x2="12" y2="5"/>
          <line x1="12" y1="19" x2="12" y2="22"/>
          <line x1="2"  y1="12" x2="5"  y2="12"/>
          <line x1="19" y1="12" x2="22" y2="12"/>
          <line x1="17" y1="7"  x2="19" y2="5"/>
          <line x1="7"  y1="17" x2="5"  y2="19"/>
          <line x1="7"  y1="7"  x2="5"  y2="5"/>
          <line x1="17" y1="17" x2="19" y2="19"/>
        </svg>
      </button>

      <!-- Week -->
      <button class="neu-btn" aria-label="Week view" aria-pressed="false" data-view="week" title="Week">
        <svg viewBox="0 0 24 24" aria-hidden="true">
          <rect x="4" y="5" width="16" height="14" rx="2"/>
          <line x1="4" y1="8" x2="20" y2="8"/>
          <line x1="6" y1="10" x2="6" y2="18"/>
          <line x1="8" y1="10" x2="8" y2="18"/>
          <line x1="10" y1="10" x2="10" y2="18"/>
          <line x1="12" y1="10" x2="12" y2="18"/>
          <line x1="14" y1="10" x2="14" y2="18"/>
          <line x1="16" y1="10" x2="16" y2="18"/>
          <line x1="18" y1="10" x2="18" y2="18"/>
        </svg>
      </button>

      <!-- Month -->
      <button class="neu-btn" aria-label="Month view" aria-pressed="false" data-view="month" title="Month">
        <svg viewBox="0 0 24 24" aria-hidden="true">
          <rect x="4" y="5" width="16" height="14" rx="2"/>
          <line x1="4" y1="8" x2="20" y2="8"/>
          <circle cx="7"  cy="11" r="0.7"/><circle cx="11" cy="11" r="0.7"/><circle cx="15" cy="11" r="0.7"/><circle cx="19" cy="11" r="0.7"/>
          <circle cx="7"  cy="14" r="0.7"/><circle cx="11" cy="14" r="0.7"/><circle cx="15" cy="14" r="0.7"/><circle cx="19" cy="14" r="0.7"/>
          <circle cx="7"  cy="17" r="0.7"/><circle cx="11" cy="17" r="0.7"/><circle cx="15" cy="17" r="0.7"/><circle cx="19" cy="17" r="0.7"/>
        </svg>
      </button>

      <!-- To-Do -->
      <button class="neu-btn" aria-label="To-Do list" aria-pressed="false" data-view="todo" title="To-Do">
        <svg viewBox="0 0 24 24" aria-hidden="true">
          <rect x="4" y="5" width="16" height="14" rx="2"/>
          <line x1="4" y1="8" x2="20" y2="8"/>
          <polyline points="7,14 10,17 17,10"/>
        </svg>
      </button>
    </nav>
  </main>

<script>
console.info('Chrono build r52 — neuromorphic UI, week-only selector buttons, boundary-cross confirm, 24h contiguous span');

/* ------------------- Utilities ------------------- */
const screenEl = document.getElementById('screen');
const buttons = [...document.querySelectorAll('.neu-btn')];

let activeView = null;
let activeDayISO = toISO(new Date());
let visibleWeekFirst = weekStart(new Date()); // Sunday-first

const SHORT_DOW=['Sun','Mon','Tue','Wed','Thu','Fri','Sat']; // 0..6

function toISO(d){ return `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')}`; }
function addDays(d,n){ const x=new Date(d); x.setDate(x.getDate()+n); return x; }
function weekStart(d){ const x=new Date(d.getFullYear(), d.getMonth(), d.getDate()); const dow=x.getDay(); x.setDate(x.getDate()-dow); x.setHours(0,0,0,0); return x; }
function startOfDay(d){ const x=new Date(d); x.setHours(0,0,0,0); return x; }
function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }
function toHHMM(min){ const mm = ((Math.round(min)|0)+1440)%1440; const h = Math.floor(mm/60), r = mm%60; return `${String(h).padStart(2,'0')}:${String(r).padStart(2,'0')}`; }
function snap15(n){ return 15 * Math.round((+n||0)/15); }
function totalDur(a){ return (a.endMin - a.startMin); }

/* numeric week stamps */
const DAY_MS = 86400000;
function weekStamp(d){ return +weekStart(d); }
function stampToDate(st){ return new Date(st); }
function getVisibleWeekStamp(){ return weekStamp(visibleWeekFirst); }

/* Width sync */
new ResizeObserver(()=> {
  const w = screenEl.getBoundingClientRect().width;
  document.documentElement.style.setProperty('--panelW', Math.max(320, Math.floor(w))+'px');
}).observe(screenEl);

/* ------------------- Storage ------------------- */
const DB_NAME='chronoDB', DB_VERSION=24;
let dbPromise=null, STORAGE_MODE='idb';
function idbSupported(){ try { return !!window.indexedDB; } catch { return false; } }
function idbOpen(){
  if(!idbSupported()){ STORAGE_MODE='ls'; return Promise.resolve(null); }
  if(dbPromise) return dbPromise;
  dbPromise = new Promise((resolve,reject)=>{
    const req = indexedDB.open(DB_NAME, DB_VERSION);
    req.onupgradeneeded = ()=>{ const db = req.result; if(!db.objectStoreNames.contains('kv')) db.createObjectStore('kv',{keyPath:'k'}); };
    req.onsuccess = ()=>resolve(req.result);
    req.onerror   = ()=>reject(req.error);
  });
  return dbPromise.catch(()=>{ STORAGE_MODE='ls'; return null; });
}
async function storageSet(k,v){
  if(STORAGE_MODE==='ls'){ if(v===undefined) localStorage.removeItem(k); else localStorage.setItem(k, JSON.stringify(v)); return true; }
  const db = await idbOpen(); if(!db){ STORAGE_MODE='ls'; return storageSet(k,v); }
  return new Promise((res,rej)=>{
    const tx=db.transaction('kv','readwrite');
    const store=tx.objectStore('kv');
    if(v===undefined) store.delete(k); else store.put({k,v});
    tx.oncomplete=()=>res(true); tx.onerror = ()=>rej(tx.error);
  });
}
async function storageGet(k){
  if(STORAGE_MODE==='ls'){ const s=localStorage.getItem(k); return s? JSON.parse(s):undefined; }
  const db = await idbOpen(); if(!db){ STORAGE_MODE='ls'; return storageGet(k); }
  return new Promise((res,rej)=>{
    const tx=db.transaction('kv','readonly');
    const req=tx.objectStore('kv').get(k);
    req.onsuccess=()=>res(req.result? req.result.v:undefined);
    req.onerror=()=>rej(req.error);
  });
}

/* ------------------- Selector chain (single) ------------------- */
const CHAIN_KEY='selChain_v12';
async function saveChain(c){ await storageSet(CHAIN_KEY, c||undefined); }
async function loadChain(){ return (await storageGet(CHAIN_KEY)) || null; }

let chain = null;

/* Spillover confirm state */
let edgeOpen=false;
let pendingEdge=null; // {direction:'prev'|'next'}

/* Drag gesture state */
let dragKind=null;               // 'top'|'bottom'
let dragTarget='parent';
let dragStartY=0, baseStart=0, baseEnd=0;
let baseOtherStart=0, baseOtherEnd=0, otherDurAtStart=0;
let dragPixels=0, wasDrag=false, createdAt=0;

/* Boundary-cross tracking (to avoid mid-row popups) */
let crossedTop=false, crossedBottom=false, prevStartMin=0, prevEndMin=0;

/* Lock after opening settings once */
let selectionLockId=null;

/* ------------------- Controls ------------------- */
document.querySelector('.controls').addEventListener('click', e=>{
  const b=e.target.closest('.neu-btn'); if(!b) return;
  const v=b.dataset.view;

  const wasPressed = b.classList.contains('is-pressed');
  buttons.forEach(x=>{ x.classList.remove('is-pressed'); x.setAttribute('aria-pressed','false'); });
  if(!wasPressed){ b.classList.add('is-pressed'); b.setAttribute('aria-pressed','true'); }

  if(activeView===v){
    activeView=null; buttons.forEach(x=>x.setAttribute('aria-pressed','false')); screenEl.innerHTML='';
    destroySelButtons();
  }else{
    activeView=v; render();
  }
  saveSoon(200);
});

/* ------------------- Week View ------------------- */
let weekGeom=null;

function buildWeekView(){
  screenEl.innerHTML = `
    <div class="wrap">
      <div class="head">
        <button id="prevWeekBtn" class="neu-btn--sm" aria-label="Previous week" title="Previous">
          <svg viewBox="0 0 24 24" aria-hidden="true"><polyline points="15,5 8,12 15,19"/></svg>
        </button>
        <div class="title" id="weekTitle"></div>
        <button id="nextWeekBtn" class="neu-btn--sm" aria-label="Next week" title="Next">
          <svg viewBox="0 0 24 24" aria-hidden="true"><polyline points="9,5 16,12 9,19"/></svg>
        </button>
      </div>

      <div class="grid-area">
        <div class="top-row week" id="dowPills"></div>
        <div class="grid" id="weekGrid" aria-label="Weekly grid" role="grid">
          <div class="blocks" id="blocksLayer"></div>
          <svg class="mask" id="maskSVG" aria-hidden="true"></svg>
          <div class="now" id="nowMagnify" aria-hidden="true"></div>
          <div class="selHost" id="selHost" aria-hidden="false"></div>
          <div class="hint" id="weekHint">Tap anywhere to edit</div>
        </div>
        <div class="hours" id="weekHours"></div>
      </div>
    </div>
  `;

  document.getElementById('prevWeekBtn').onclick=async ()=>{ visibleWeekFirst=addDays(visibleWeekFirst,-7); repaintWeek(); await loadAndDraw(); saveSoon(200); };
  document.getElementById('nextWeekBtn').onclick=async ()=>{ visibleWeekFirst=addDays(visibleWeekFirst, 7); repaintWeek(); await loadAndDraw(); saveSoon(200); };

  const grid=document.getElementById('weekGrid');
  grid.addEventListener('click', onWeekGridTap, {passive:true});

  repaintWeek();
  new ResizeObserver(()=>{ repaintWeek(true); drawSelection(); }).observe(grid);

  const syncViewport = throttle(()=>{ if(activeView==='week'){ repaintWeek(true); drawSelection(); } }, 32);
  window.addEventListener('scroll', syncViewport, {passive:true});
  window.addEventListener('orientationchange', syncViewport, {passive:true});
  if (window.visualViewport) window.visualViewport.addEventListener('resize', syncViewport, {passive:true});

  loadAndDraw().catch(()=>{});
  try{
    if(!localStorage.getItem('hint_week_edit_r50')){
      const hint=document.getElementById('weekHint');
      requestAnimationFrame(()=>{ hint.classList.add('show'); setTimeout(()=>hint.classList.remove('show'), 2200); });
      localStorage.setItem('hint_week_edit_r50','1');
    }
  }catch{}
}

async function loadAndDraw(){ chain = await loadChain(); drawSelection(); }

function repaintWeek(skipSel=false){
  const first=visibleWeekFirst, last=addDays(first,6);
  const m=new Intl.DateTimeFormat(undefined,{month:'short'});
  const title = (first.getFullYear()===last.getFullYear())
    ? (first.getMonth()===last.getMonth()
        ? `${m.format(first)} ${first.getDate()} – ${last.getDate()}, ${first.getFullYear()}`
        : `${m.format(first)} ${first.getDate()} – ${m.format(last)} ${last.getDate()}, ${first.getFullYear()}`)
    : `${m.format(first)} ${first.getDate()}, ${first.getFullYear()} – ${m.format(last)} ${last.getDate()}, ${last.getFullYear()}`;
  document.getElementById('weekTitle').textContent=title;

  const pills=document.getElementById('dowPills'); pills.innerHTML='';
  for(let i=0;i<7;i++){ const d=addDays(first,i); const el=document.createElement('div'); el.className='day-pill'; el.textContent = `${SHORT_DOW[i]}, ${d.getDate()}`; pills.appendChild(el); }

  const gh=document.getElementById('weekHours'); gh.innerHTML='';
  const gridEl=document.getElementById('weekGrid');
  weekGeom=computeGeometry(gridEl,7);
  for(let i=0;i<24;i++){ const s=document.createElement('div'); s.className='hour-stamp'; s.textContent = `${String(i).padStart(2,'0')}:00`; s.style.top=((weekGeom.rowY[i]+weekGeom.rowY[i+1])/2)+'px'; gh.appendChild(s); }

  buildMask(weekGeom,7);
  paintNowMagnifier(weekGeom);

  if(chain && !skipSel) drawSelection();
}

function computeGeometry(gridEl, cols){
  const r=gridEl.getBoundingClientRect();
  const totalW=Math.max(0, Math.round(r.width));
  const totalH=Math.max(0, Math.round(r.height));
  const colWBase=Math.floor(totalW/cols), extraW=totalW-colWBase*cols;
  const rowHBase=Math.floor(totalH/24), extraH=totalH-rowHBase*24;

  const colW=[], colX=[0]; for(let c=0;c<cols;c++){ const w=colWBase+(c<extraW?1:0); colW.push(w); colX.push(colX[c]+w); }
  const rowH=[], rowY=[0]; for(let i=0;i<24;i++){ const h=rowHBase+(i<extraH?1:0); rowH.push(h); rowY.push(rowY[i]+h); }

  const slotY=[0];
  for(let hr=0;hr<24;hr++){
    const h=rowH[hr];
    const base=Math.floor(h/4); let rem=h-base*4;
    const parts=[base,base,base,base]; for(let k=0;k<rem;k++) parts[k]+=1;
    for(let q=0;q<4;q++) slotY.push(slotY[slotY.length-1]+parts[q]);
  }
  return {totalW,totalH,colW,colX,rowH,rowY,slotY, rect:r};
}

function buildMask(geom, cols){
  const svg=document.getElementById('maskSVG'); svg.innerHTML='';
  const { totalW, totalH, colX, rowY } = geom;
  if(totalW<=0 || totalH<=0) return;
  svg.setAttribute('width', totalW);
  svg.setAttribute('height', totalH);
  svg.setAttribute('viewBox', `0 0 ${totalW} ${totalH}`);
  svg.setAttribute('preserveAspectRatio','none');

  const NS='http://www.w3.org/2000/svg';
  const defs=document.createElementNS(NS,'defs');
  const sym=document.createElementNS(NS,'symbol');
  sym.setAttribute('id','tile900x300');
  sym.setAttribute('viewBox','0 0 900 300');
  sym.setAttribute('preserveAspectRatio','none');

  const surface='rgba(255,255,255,0.55)';
  const r=(x,y,w,h)=>{const e=document.createElementNS(NS,'rect'); e.setAttribute('x',x); e.setAttribute('y',y); e.setAttribute('width',w); e.setAttribute('height',h); e.setAttribute('fill',surface); return e;};
  const p=(pts)=>{const e=document.createElementNS(NS,'polygon'); e.setAttribute('points',pts); e.setAttribute('fill',surface); return e;};

  sym.appendChild(r(0,0,900,24)); sym.appendChild(r(0,276,900,24));
  sym.appendChild(r(0,0,24,300)); sym.appendChild(r(876,0,24,300));
  sym.appendChild(r(24,69,852,24)); sym.appendChild(r(24,138,852,24)); sym.appendChild(r(24,207,852,24));
  sym.appendChild(p('23,23 61,23 23,61')); sym.appendChild(p('877,23 839,23 877,61')); sym.appendChild(p('23,277 61,277 23,239')); sym.appendChild(p('877,277 839,277 877,239'));

  defs.appendChild(sym); svg.appendChild(defs);

  for(let rI=0;rI<24;rI++){
    for(let cI=0;cI<cols;cI++){
      const use=document.createElementNS(NS,'use');
      use.setAttribute('href','#tile900x300');
      use.setAttribute('x',colX[cI]); use.setAttribute('y',rowY[rI]);
      use.setAttribute('width',colX[cI+1]-colX[cI]);
      use.setAttribute('height',rowY[rI+1]-rowY[rI]);
      svg.appendChild(use);
    }
  }
}

function paintNowMagnifier(geom){
  const nowEl=document.getElementById('nowMagnify');
  const today=new Date(); const visStart=visibleWeekFirst; const visEnd=addDays(visStart,6);
  if(+startOfDay(today) < +startOfDay(visStart) || +startOfDay(today) > +startOfDay(visEnd)){ nowEl.style.display='none'; return; }
  const {colX,rowY} = geom;
  const dow=today.getDay(); const mins=today.getHours()*60 + today.getMinutes();
  const hour=Math.floor(mins/60);
  const hourTop=rowY[hour]; const hourH=rowY[hour+1]-rowY[hour];
  const extra=Math.min(10, Math.floor(hourH*0.25));
  const top=Math.max(0, hourTop - Math.floor(extra/2));
  const height=Math.max(2, hourH + extra);
  nowEl.style.left=colX[dow]+'px';
  nowEl.style.top=top+'px';
  nowEl.style.width=(colX[dow+1]-colX[dow] - (dow===6?1:0))+'px';
  nowEl.style.height=height+'px';
  nowEl.style.display='block';
}

/* ------------------- Tap to create parent ------------------- */
async function onWeekGridTap(e){
  if(edgeOpen || !weekGeom) return;
  removeEdgeConfirm(); pendingEdge=null;

  const rect=weekGeom.rect;
  const relX=e.clientX - rect.left;
  const relY=e.clientY - rect.top;

  let dayIdx=0;
  for(let i=0;i<7;i++){ if(relX >= weekGeom.colX[i] && relX < weekGeom.colX[i+1]){ dayIdx=i; break; } }

  const minuteFloat = clamp(relY / weekGeom.totalH, 0, 1) * 1440;
  const startMin = snap15(Math.floor(minuteFloat/60)*60);
  const endMin   = clamp(startMin + 60, 0, 1440);

  chain = {
    id: Date.now(),
    parent: { weekSt:getVisibleWeekStamp(), dayIdx, startMin, endMin },
    child: null,
    dir: null
  };
  selectionLockId=null;
  createdAt = Date.now(); wasDrag=false;
  await saveChain(chain);
  drawSelection();
}

/* ------------------- Draw selection ------------------- */
function minutesToY(min){ const idx = clamp(Math.round(min/15), 0, 96); return weekGeom.slotY[idx]; }
function segOnThisWeek(seg){ return seg && seg.weekSt === getVisibleWeekStamp(); }
function segDowLabel(seg){
  const d = new Date(seg.weekSt + seg.dayIdx*DAY_MS);
  return SHORT_DOW[d.getDay()];
}

function boundsFromSeg(seg){
  const colLeft = weekGeom.colX[seg.dayIdx];
  const colRight= weekGeom.colX[seg.dayIdx+1];
  const colWidth= (colRight - colLeft) - (seg.dayIdx===6?1:0);
  const topY  = minutesToY(seg.startMin);
  const botY  = minutesToY(seg.endMin);
  const height= Math.max(1, botY - topY);
  const offsetLeft = colLeft;
  const offsetTop  = 0;
  return {offsetLeft, offsetTop, colWidth, topY, botY, height};
}

function drawSelection(){
  const host=document.getElementById('selHost'); if(!host) { destroySelButtons(); return; }
  host.innerHTML='';
  if(!chain){ destroySelButtons(); return; }

  const parentHere = segOnThisWeek(chain.parent);
  const childHere  = segOnThisWeek(chain.child);
  if(!parentHere && !childHere){ destroySelButtons(); return; }

  const segs=[];
  if(parentHere) segs.push({seg:chain.parent, name:'parent'});
  if(childHere)  segs.push({seg:chain.child,  name:'child'});
  segs.sort((a,b)=>a.seg.dayIdx-b.seg.dayIdx);

  const bothVisible = parentHere && childHere;

  segs.forEach((entry, idx)=>{
    const seg=entry.seg, name=entry.name;
    const b=boundsFromSeg(seg);

    const m=document.createElement('div');
    m.className='marquee';

    let renderTop=false, renderBottom=false;
    if(!chain.child){
      renderTop = renderBottom = true;
    }else if(bothVisible){
      renderTop = (idx===0);
      renderBottom = (idx===segs.length-1);
    }else{
      if(chain.dir==='next'){
        if(name==='parent') renderTop=true; else renderBottom=true;
      }else if(chain.dir==='prev'){
        if(name==='parent') renderBottom=true; else renderTop=true;
      }
    }

    m.innerHTML=`
      <div class="marqueeRect" data-name="${name}"></div>
      ${renderTop ? `
        <div class="stamp" id="topStamp_${name}"></div>
        <div class="handle" id="topHandle_${name}">
          <svg viewBox="0 0 100 48" preserveAspectRatio="none" aria-hidden="true"><polygon points="1,47 50,3 99,47"></polygon></svg>
        </div>` : ''}
      ${renderBottom ? `
        <div class="stamp" id="botStamp_${name}"></div>
        <div class="handle" id="botHandle_${name}">
          <svg viewBox="0 0 100 48" preserveAspectRatio="none" aria-hidden="true"><polygon points="1,3 50,47 99,3"></polygon></svg>
        </div>` : ''}
    `;
    host.appendChild(m);

    const rectEl = m.querySelector('.marqueeRect');
    rectEl.style.left   = `${b.offsetLeft}px`;
    rectEl.style.top    = `${b.offsetTop + b.topY}px`;
    rectEl.style.width  = `${b.colWidth}px`;
    rectEl.style.height = `${b.height}px`;

    const stampPad=6, triH=parseInt(getComputedStyle(document.documentElement).getPropertyValue('--handle-height'))||48;
    const stampH=26;

    if(renderTop){
      const topStamp=m.querySelector(`#topStamp_${name}`);
      topStamp.textContent = `${segDowLabel(seg)} ${toHHMM(seg.startMin)}`;
      topStamp.style.left = `${b.offsetLeft + b.colWidth/2}px`;
      topStamp.style.top  = `${b.topY - (stampH + stampPad)}px`;

      const topHandle=m.querySelector(`#topHandle_${name}`);
      topHandle.style.left  = `${b.offsetLeft}px`;
      topHandle.style.top   = `${b.topY - (stampH + stampPad + triH)}px`;
      topHandle.style.width = `${b.colWidth}px`;
      topHandle.style.height= `${triH}px`;
      topHandle.addEventListener('pointerdown', ev=>startDrag(ev,'top', name));
    }

    if(renderBottom){
      const botStamp=m.querySelector(`#botStamp_${name}`);
      botStamp.textContent = `${segDowLabel(seg)} ${toHHMM(seg.endMin)}`;
      botStamp.style.left = `${b.offsetLeft + b.colWidth/2}px`;
      botStamp.style.top  = `${b.botY + stampPad}px`;

      const botHandle=m.querySelector(`#botHandle_${name}`);
      botHandle.style.left  = `${b.offsetLeft}px`;
      botHandle.style.top   = `${b.botY + stampPad + stampH}px`;
      botHandle.style.width = `${b.colWidth}px`;
      botHandle.style.height= `${triH}px`;
      botHandle.addEventListener('pointerdown', ev=>startDrag(ev,'bottom', name));
    }
  });

  ensureSelButtons();                 // week-only singleton
  repositionSelButtons();             // follow
  attachViewportRepositioners();
}

/* ------------------- Drag logic (no wrong-end jumps; contiguous 24h) ------------------- */
function otherSeg(which){ return which==='parent' ? chain.child : chain.parent; }
function dur(seg){ return seg? seg.endMin - seg.startMin : 0; }

function clampToBudget(seg, which){
  const minGap=15;
  const hasChild = !!chain.child && !!chain.dir;

  // Only constrain the edge being dragged; keep the opposite edge frozen.
  if(!hasChild){
    seg.startMin = clamp(seg.startMin, 0, 1425);
    seg.endMin   = clamp(seg.endMin, seg.startMin + minGap, 1440);
  }else{
    const other = otherSeg(which);
    const otherDuration = dur(other);
    const maxThisDur = 1440 - otherDuration;

    // Respect fixed edges for cross-midnight continuity:
    if(chain.dir==='next' && which==='child'){ seg.startMin = 0; }
    if(chain.dir==='prev' && which==='child'){ seg.endMin   = 1440; }

    // Apply limit only through the dragged edge
    let thisDur = seg.endMin - seg.startMin;
    thisDur = clamp(thisDur, minGap, Math.max(minGap, maxThisDur));
    if(dragKind==='top'){ seg.startMin = seg.endMin - thisDur; }
    else if(dragKind==='bottom'){ seg.endMin = seg.startMin + thisDur; }

    seg.startMin = clamp(seg.startMin, 0, 1425);
    seg.endMin   = clamp(seg.endMin, seg.startMin + minGap, 1440);

    // If full 24h used, force a clean join at midnight
    const used = dur(chain.parent) + dur(chain.child);
    if(used===1440){
      if(chain.dir==='next'){ chain.parent.endMin = 1440; chain.child.startMin = 0; }
      if(chain.dir==='prev'){ chain.parent.startMin = 0;  chain.child.endMin   = 1440; }
    }
  }
}

function startDrag(ev, kind, which){
  if(!chain) return;
  const seg = (which==='parent'? chain.parent : chain.child); if(!seg) return;

  dragKind = kind; dragTarget = which;
  ev.preventDefault(); ev.stopPropagation(); ev.currentTarget.setPointerCapture(ev.pointerId);

  dragStartY = ev.clientY; baseStart = seg.startMin; baseEnd = seg.endMin;
  const other = otherSeg(which);
  if(other){
    baseOtherStart = other.startMin; baseOtherEnd = other.endMin;
    otherDurAtStart = baseOtherEnd - baseOtherStart;
  }else{
    baseOtherStart = 0; baseOtherEnd = 0; otherDurAtStart = 0;
  }

  // boundary-cross tracking
  crossedTop=crossedBottom=false;
  prevStartMin=seg.startMin; prevEndMin=seg.endMin;

  wasDrag=false; dragPixels=0;

  const move=(e)=>{
    const dyPx = e.clientY - dragStartY;
    dragPixels = Math.max(dragPixels, Math.abs(dyPx));
    if(dragPixels > 6) wasDrag=true;

    const deltaMinRaw = (weekGeom.totalH? (dyPx / weekGeom.totalH) * 1440 : 0);
    const snappedDelta = snap15(deltaMinRaw);

    // Move only the dragged edge
    if(dragKind==='top'){
      seg.startMin = clamp(baseStart + snappedDelta, 0, baseEnd - 15);
    } else if(dragKind==='bottom'){
      seg.endMin = clamp(baseEnd + snappedDelta, baseStart + 15, 1440);
    }

    // Freeze opposite edge; apply contiguous 24h budget via dragged edge only
    clampToBudget(seg, which);

    // Track boundary crossing for confirm (only when no child yet)
    if(!chain.child){
      if(prevStartMin>0 && seg.startMin===0) crossedTop=true;
      if(prevEndMin<1440 && seg.endMin===1440) crossedBottom=true;
      prevStartMin=seg.startMin; prevEndMin=seg.endMin;
    }

    drawSelection();
    repositionSelButtons(); // follow during drag
  };

  const up=async (e)=>{
    seg.startMin = snap15(seg.startMin); seg.endMin = snap15(seg.endMin);
    if(seg.endMin - seg.startMin < 15){
      if(dragKind==='top'){ seg.startMin = seg.endMin - 15; }
      else if(dragKind==='bottom'){ seg.endMin = seg.startMin + 15; }
    }

    // Only prompt when a boundary was crossed in this drag, no child yet
    if(!edgeOpen && !pendingEdge && !chain.child && wasDrag){
      if(crossedTop){ pendingEdge={direction:'prev'}; showEdgeConfirm('prev', anchorFor(seg,'top')); }
      else if(crossedBottom){ pendingEdge={direction:'next'}; showEdgeConfirm('next', anchorFor(seg,'bottom')); }
    }

    await saveChain(chain).catch(()=>{});
    saveSoon(200);

    e.currentTarget.releasePointerCapture(e.pointerId);
    window.removeEventListener('pointermove', move);
    window.removeEventListener('pointerup', up);
    dragKind=null;
  };

  window.addEventListener('pointermove', move, {passive:false});
  window.addEventListener('pointerup', up, {passive:true});
}

function anchorFor(seg, which){
  const b=boundsFromSeg(seg);
  const grid = document.getElementById('weekGrid').getBoundingClientRect();
  const x = grid.left + b.offsetLeft + b.colWidth/2;
  const y = grid.top + (which==='top' ? (b.topY - 56) : (b.botY + 56));
  return {x,y};
}

/* ------------------- Spillover confirm ------------------- */
function showEdgeConfirm(direction, anchor){
  removeEdgeConfirm(); edgeOpen = true;

  const veil=document.createElement('div');
  veil.className='edgeVeil';
  veil.addEventListener('click', (e)=>{ e.stopPropagation(); e.preventDefault(); }, {capture:true});
  document.body.appendChild(veil);

  const box=document.createElement('div');
  box.className='edgeConfirm';
  box.style.left = Math.max(12, Math.min(window.innerWidth-172, Math.round(anchor.x-80)))+'px';
  box.style.top  = Math.max(12, Math.min(window.innerHeight-90, Math.round(anchor.y-20)))+'px';
  box.innerHTML=`
    <div>${direction==='prev' ? 'Spill into previous day?' : 'Spill into next day?'}</div>
    <div class="edgeRow">
      <button class="edgeBtn" data-act="cancel" aria-label="Cancel">✕</button>
      <button class="edgeBtn ok" data-act="ok" aria-label="Confirm">✓</button>
    </div>
  `;
  document.body.appendChild(box);

  box.addEventListener('pointerdown', ev=>ev.stopPropagation());
  box.addEventListener('click', ev=>ev.stopPropagation());
  box.addEventListener('click', async (e)=>{
    const b=e.target.closest('button'); if(!b) return;
    const act=b.dataset.act;
    if(act==='cancel'){ removeEdgeConfirm(); pendingEdge=null; return; }
    if(act==='ok'){ await confirmSpill(direction); removeEdgeConfirm(); }
  });
}
function removeEdgeConfirm(){ edgeOpen=false; pendingEdge=null;
  document.querySelectorAll('.edgeConfirm').forEach(n=>n.remove());
  document.querySelectorAll('.edgeVeil').forEach(n=>n.remove());
}

/* Spillover creation: consecutive across midnight, 24h budget safe */
async function confirmSpill(direction){
  if(!chain || !chain.parent) return;

  const p = chain.parent;
  let childWeek = p.weekSt;
  let childDay  = p.dayIdx;

  chain.dir = direction;

  if(direction==='next'){
    if(p.dayIdx < 6){ childDay  = p.dayIdx + 1; childWeek = p.weekSt; }
    else { childDay  = 0; childWeek = p.weekSt + 7*DAY_MS; }
    const parentDur = totalDur(p);
    const rem = Math.max(15, Math.min(60, 1440 - parentDur));
    chain.child = { weekSt: childWeek, dayIdx: childDay, startMin:0, endMin:rem };
    // If hop, move view so edit continues there
    if(p.dayIdx === 6){ visibleWeekFirst = stampToDate(childWeek); await saveChain(chain); requestAnimationFrame(()=>{ repaintWeek(); drawSelection(); }); return; }
  }else{ // 'prev'
    if(p.dayIdx > 0){ childDay  = p.dayIdx - 1; childWeek = p.weekSt; }
    else { childDay  = 6; childWeek = p.weekSt - 7*DAY_MS; }
    const parentDur = totalDur(p);
    const rem = Math.max(15, Math.min(60, 1440 - parentDur));
    chain.child = { weekSt: childWeek, dayIdx: childDay, startMin:1440 - rem, endMin:1440 };
    if(p.dayIdx === 0){ visibleWeekFirst = stampToDate(childWeek); await saveChain(chain); requestAnimationFrame(()=>{ repaintWeek(); drawSelection(); }); return; }
  }

  await saveChain(chain);
  drawSelection();
}

/* ------------------- Month & Day Views ------------------- */
function buildMonthView(){
  const base = new Date(); activeDayISO = toISO(base);
  const first = new Date(base.getFullYear(), base.getMonth(), 1);
  const last  = new Date(base.getFullYear(), base.getMonth()+1, 0);
  const label = first.toLocaleDateString(undefined,{month:'long', year:'numeric'});

  screenEl.innerHTML = `
    <div class="month-wrap">
      <div class="head">
        <button id="prevMon" class="neu-btn--sm" aria-label="Prev month" title="Prev">
          <svg viewBox="0 0 24 24" aria-hidden="true"><polyline points="15,5 8,12 15,19"/></svg>
        </button>
        <div class="title">${label}</div>
        <button id="nextMon" class="neu-btn--sm" aria-label="Next month" title="Next">
          <svg viewBox="0 0 24 24" aria-hidden="true"><polyline points="9,5 16,12 9,19"/></svg>
        </button>
      </div>
      <div class="month-dow" aria-hidden="false">
        <span>S</span><span>M</span><span>T</span><span>W</span><span>T</span><span>F</span><span>S</span>
      </div>
      <div class="month-grid" id="monthGrid"></div>
    </div>
  `;
  document.getElementById('prevMon').onclick=()=>{ activeDayISO = toISO(new Date(base.getFullYear(), base.getMonth()-1, 1)); buildMonthView(); saveSoon(200); };
  document.getElementById('nextMon').onclick=()=>{ activeDayISO = toISO(new Date(base.getFullYear(), base.getMonth()+1, 1)); buildMonthView(); saveSoon(200); };

  const g=document.getElementById('monthGrid'); g.innerHTML='';
  const firstWeekday = first.getDay();
  const prevLast = new Date(base.getFullYear(), base.getMonth(), 0).getDate();
  for(let i=firstWeekday-1;i>=0;i--){ const el=document.createElement('div'); el.className='mcell muted'; el.textContent=(prevLast - i); g.appendChild(el); }
  for(let day=1; day<=last.getDate(); day++){
    const tile=document.createElement('div'); tile.className='mcell'; tile.textContent=day;
    const iso = toISO(new Date(base.getFullYear(), base.getMonth(), day));
    if(iso===toISO(new Date())) tile.classList.add('today');
    g.appendChild(tile);
  }
  const used = firstWeekday + last.getDate();
  const rem = (Math.ceil(used/7)*7) - used;
  for(let i=1;i<=rem;i++){ const el=document.createElement('div'); el.className='mcell muted'; el.textContent=i; g.appendChild(el); }

  destroySelButtons(); // strict: not in Month
}

function buildDayView(){
  screenEl.innerHTML = `
    <div class="wrap">
      <div class="head"><div></div><div class="title">Day</div><div></div></div>
      <div class="grid-area" style="display:grid;place-items:center;color:#666">
        <div class="watermark">Chrono build r52</div>
      </div>
    </div>
  `;
  destroySelButtons(); // strict: not in Day
}

/* ------------------- Init & render ------------------- */
function snapshotState(){ return { activeView, activeDayISO, visibleWeekFirst:+visibleWeekFirst }; }
async function saveAll(){ await storageSet('state', snapshotState()); await saveChain(chain); }
let saveTimer=null; function saveSoon(ms=300){ clearTimeout(saveTimer); saveTimer=setTimeout(()=>{ saveAll().catch(()=>{}); }, ms); }

async function init(){
  try{
    const snap = await storageGet('state');
    if(snap && typeof snap==='object'){
      if('activeView' in snap) activeView = snap.activeView;
      if('activeDayISO' in snap) activeDayISO = snap.activeDayISO;
      if('visibleWeekFirst' in snap && typeof snap.visibleWeekFirst==='number') visibleWeekFirst = new Date(snap.visibleWeekFirst);
    }
  }catch{}

  render();

  document.addEventListener('visibilitychange', ()=>{ if(document.visibilityState==='hidden') saveAll().catch(()=>{}); });
  window.addEventListener('beforeunload', ()=>{ saveAll().catch(()=>{}); });
}

function render(){
  if(activeView==='week'){
    buildWeekView();
  } else if(activeView==='day'){
    activeDayISO = toISO(new Date());
    buildDayView();
  } else if(activeView==='month'){
    activeDayISO = toISO(new Date());
    buildMonthView();
  } else {
    screenEl.innerHTML='';
    destroySelButtons();
  }
}
init();

/* ------------------- helpers ------------------- */
function throttle(fn, ms){
  let t=0, lastArgs=null;
  return function(...args){
    lastArgs=args;
    if(!t){
      t=setTimeout(()=>{ t=0; fn.apply(null,lastArgs); }, ms);
    }
  }
}

/* ===== Week-only floating buttons + modal ===== */
function ensureSelButtons(){
  if(activeView!=='week') { destroySelButtons(); return; }
  if(window.__selBtns) { window.__selBtns.style.display='grid'; return; }

  const wrap = document.createElement('div');
  wrap.className='selBtns';
  wrap.id='selBtns';

  // Settings (gear)
  const gear = document.createElement('button');
  gear.className='neu-btn--sm';
  gear.setAttribute('aria-label', 'Settings');
  gear.innerHTML = `<svg viewBox="0 0 24 24" aria-hidden="true">
    <path d="M12 15.5a3.5 3.5 0 1 1 0-7 3.5 3.5 0 0 1 0 7Z"/>
    <path d="M19 12a7 7 0 0 0-.09-1l2.02-1.56-2-3.46-2.39.73a7.1 7.1 0 0 0-1.73-1l-.36-2.45h-4l-.36 2.45a7.1 7.1 0 0 0-1.73 1l-2.39-.73-2 3.46L5.09 11a7 7 0 0 0 0 2l-2.02 1.56 2 3.46 2.39-.73c.52.42 1.1.78 1.73 1l.36 2.45h4l.36-2.45c.63-.22 1.21-.58 1.73-1l2.39.73 2-3.46L18.91 13c.06-.33.09-.66.09-1Z" fill="none" stroke="currentColor" stroke-width="1.6" stroke-linejoin="round"/></svg>`;
  gear.addEventListener('click', onGearTap);

  // Clear (X)
  const close = document.createElement('button');
  close.className='neu-btn--sm';
  close.setAttribute('aria-label', 'Clear selection');
  close.innerHTML = `<svg viewBox="0 0 24 24" aria-hidden="true"><path d="M6 6l12 12M18 6L6 18" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"/></svg>`;
  close.addEventListener('click', onXTap);

  wrap.appendChild(gear);
  wrap.appendChild(close);
  document.body.appendChild(wrap);
  window.__selBtns = wrap;
}

function destroySelButtons(){ window.__selBtns?.remove(); window.__selBtns=null; }
function hideSelButtons(){ if(window.__selBtns) window.__selBtns.style.display='none'; }

function visibleSegName(){
  if(!chain) return null;
  if(dragTarget && segOnThisWeek(chain[dragTarget])) return dragTarget;
  if(segOnThisWeek(chain.parent)) return 'parent';
  if(segOnThisWeek(chain.child))  return 'child';
  return null;
}
function getRectForSegName(name){
  const host=document.getElementById('selHost'); if(!host || !name) return null;
  const rectEl = host.querySelector(`.marqueeRect[data-name="${name}"]`);
  return rectEl ? rectEl.getBoundingClientRect() : null;
}

function repositionSelButtons(){
  const pair = window.__selBtns; if(!pair){ return; }
  const name = visibleSegName(); const r = getRectForSegName(name);
  if(!r){ hideSelButtons(); return; }
  pair.style.display='grid';

  const margin=8, btnW=44, totalH=(44*2)+8;
  let left = r.right + margin;
  let top  = r.top + margin;

  if(left + btnW > window.innerWidth - margin){
    left = Math.max(margin, r.left - margin - btnW);
  }
  if(top + totalH > window.innerHeight - margin){
    top = Math.max(margin, window.innerHeight - margin - totalH);
  }
  if(top < margin) top = margin;

  pair.style.left = `${Math.round(left)}px`;
  pair.style.top  = `${Math.round(top)}px`;
}

let _vpAttached=false;
function attachViewportRepositioners(){
  if(_vpAttached) return;
  _vpAttached=true;
  const handler = throttle(()=>{ repositionSelButtons(); }, 16);
  window.addEventListener('scroll', handler, {passive:true});
  window.addEventListener('resize', handler, {passive:true});
  window.addEventListener('orientationchange', handler, {passive:true});
  if(window.visualViewport) window.visualViewport.addEventListener('resize', handler, {passive:true});
}

/* Align selection edge to the vertical center of the button stack (first tap) */
function alignSelectionToButtons(){
  if(!chain || !window.__selBtns || activeView!=='week') return;

  // Skip if already locked for this selection
  // (only Gear sets lock; X still aligns then clears)
  const selId = chain.id;

  const btnRect = window.__selBtns.getBoundingClientRect();
  const targetY = btnRect.top + (btnRect.height/2);

  const gridRect = weekGeom.rect;
  const relY = clamp(targetY - gridRect.top, 0, weekGeom.totalH);
  const minuteFloat = (relY / weekGeom.totalH) * 1440;
  const snapped = snap15(minuteFloat);

  const name = visibleSegName();
  if(!name) return;
  const seg = name==='parent'? chain.parent : chain.child;

  // Choose the edge that is exposed for this visible segment
  const parentHere = segOnThisWeek(chain.parent);
  const childHere = segOnThisWeek(chain.child);
  let edge='bottom';
  if(!chain.child){ edge = (snapped < (seg.startMin + seg.endMin)/2) ? 'top' : 'bottom'; }
  else if(parentHere && childHere){
    // outer edges only
    if(name==='parent') edge='top'; else edge='bottom';
  }else{
    if(chain.dir==='next'){ edge = (name==='parent') ? 'top' : 'bottom'; }
    if(chain.dir==='prev'){ edge = (name==='parent') ? 'bottom' : 'top'; }
  }

  if(edge==='top'){ seg.startMin = clamp(snap15(snapped), 0, seg.endMin - 15); dragKind='top'; }
  else { seg.endMin = clamp(snap15(snapped), seg.startMin + 15, 1440); dragKind='bottom'; }

  clampToBudget(seg, name);
  dragKind=null;
  drawSelection();
}

/* Settings modal */
function onGearTap(){
  if(!chain) return;

  // First gear tap on this selection → align once
  if(selectionLockId !== chain.id){ alignSelectionToButtons(); selectionLockId = chain.id; }

  const veil = document.createElement('div'); veil.className='settingsVeil';
  const modal = document.createElement('div'); modal.className='settingsModal';
  modal.innerHTML = `
    <div class="settingsHead">
      <div>Settings</div>
      <button class="closeBtn" aria-label="Close">✕</button>
    </div>
    <div class="settingsBody"><em>Blank settings window</em></div>
    <div class="settingsFoot"><button class="closeBtn ok">Exit</button></div>
  `;
  const closeAll = ()=>{ veil.remove(); modal.remove(); };
  veil.addEventListener('click', closeAll);
  modal.querySelectorAll('.closeBtn').forEach(b=>b.addEventListener('click', closeAll));
  document.body.appendChild(veil);
  document.body.appendChild(modal);
}

/* Clear selection */
async function onXTap(){
  if(!chain) return;
  alignSelectionToButtons(); // snap first (per spec), then clear
  removeEdgeConfirm();
  chain = null;
  selectionLockId=null;
  await saveChain(null).catch(()=>{});
  document.getElementById('selHost')?.replaceChildren();
  destroySelButtons();
}
</script>

<!-- Service worker registration (unchanged) -->
<script>
if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('./service-worker.js')
      .then(reg => console.log('SW registered', reg.scope))
      .catch(err => console.error('SW registration failed', err));
  });
}
</script>

</body>
</html>