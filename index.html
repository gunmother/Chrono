<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Betterly â€” Scheduler</title>
<style>
  :root{
    /* Layout */
    --uiw: 360px;
    --toph: 0px;                /* no top bar */
    --gap: 8px;                 /* minimal margins */
    --centerh: 560px;
    --dockh: 92px;

    /* Theme */
    --page:#ffffff;
    --panel:#ffffff;
    --ink:#0F172A;
    --muted:#64748B;
    --border:#D1D7E0;

    /* Charts */
    --chart-bg:#E9EDF3;         /* slightly gray so mask lines are visible */
    --grid-hour:#C9D2DF;
    --grid-15:#DDE3EC;

    /* Sizing */
    --hour-col: 56px;
    --label: 11px;
    --title: 18px;
    --dow-h: 16px;

    /* Z */
    --z-overlay: 100;
    --z-settings: 140;
  }

  html,body{height:100%;margin:0;background:var(--page);color:var(--ink);font:500 16px/1.4 system-ui,-apple-system,"Segoe UI",Roboto,Arial;-webkit-font-smoothing:antialiased;overflow:hidden}
  *{box-sizing:border-box}

  /* App shell */
  .app{
    width:clamp(320px, 92vw, var(--uiw));
    height:calc(100svh - max(10px, env(safe-area-inset-top)) - max(10px, env(safe-area-inset-bottom)));
    margin: max(10px, env(safe-area-inset-top)) auto max(10px, env(safe-area-inset-bottom));
    display:grid; grid-template-rows: 1fr auto; gap: var(--gap);
  }

  /* Center screen (panel) */
  .center{
    background:var(--panel);
    border:1px solid var(--border);
    border-radius:12px;
    overflow:hidden;
    position:relative;
  }

  /* Bottom dock (4 buttons) */
  .dock{
    height:var(--dockh);
    background:var(--panel);
    border:1px solid var(--border);
    border-radius:12px;
    display:flex; align-items:center; justify-content:space-around;
  }
  .pill{
    width:64px; height:64px; border-radius:50%;
    background:#fff; border:1px solid var(--border);
    display:grid; place-items:center;
    cursor:pointer; user-select:none;
  }
  .pill.active{ background:#cfcfcf; }

  /* Views */
  .view{ position:absolute; inset:0; display:none; }
  .view.active{ display:block; }

  /* Header bars inside views */
  .header{
    display:grid; grid-template-columns:40px 1fr 40px; align-items:center;
    padding:8px; border-bottom:1px solid var(--border);
  }
  .chev{ display:grid; place-items:center; }
  .chev button{
    width:28px; height:28px; border:1px solid var(--border); border-radius:8px; background:#fff; cursor:pointer;
    display:grid; place-items:center; padding:0;
  }
  .chev button .icon{ font-size:14px; line-height:1; }
  .title{ text-align:center; font-weight:800; font-size:var(--title); }

  /* Weekly */
  .week-wrap{ position:absolute; inset:0; display:grid; grid-template-rows: auto 1fr; }
  .dow-bar{
    display:grid; grid-template-columns: var(--hour-col) repeat(7, 1fr);
    align-items:center; gap:0; padding:6px 6px 4px; border-bottom:1px solid var(--border);
  }
  .dow-bar .spacer{ height:1px; }
  .dow{
    justify-self:center;
    font-size:12px; font-weight:800;
  }

  .chart{ position:relative; background:var(--chart-bg); }
  .hours-col{
    position:absolute; top:0; bottom:0; left:0; width:var(--hour-col);
    border-right:1px solid var(--border);
  }
  .hour-label{
    position:absolute; left:6px; transform:translateY(-50%); font-size:var(--label); color:#334155; opacity:.95;
  }

  .grid{
    position:absolute; top:0; bottom:0; left:var(--hour-col); right:0;
  }
  /* mask lines */
  .grid .hour{
    position:absolute; left:0; right:0; height:1px; background:var(--grid-hour);
  }
  .grid .q{
    position:absolute; left:0; right:0; height:1px; background:var(--grid-15);
  }

  .blocks{
    position:absolute; top:0; bottom:0; left:var(--hour-col); right:0; pointer-events:none;
  }
  .blk{
    position:absolute; border-radius:2px; pointer-events:auto; /* allow hit for future features if needed */
  }

  /* Day view (single column stretched full width) */
  .day-wrap{ position:absolute; inset:0; display:grid; grid-template-rows:auto 1fr; }
  .day-header{ display:grid; grid-template-columns:1fr; padding:8px; border-bottom:1px solid var(--border); }
  .day-title{ text-align:center; font-weight:800; font-size:var(--title); }

  /* Month view */
  .month-wrap{ position:absolute; inset:0; display:grid; grid-template-rows:auto 1fr; }
  .month-header{ padding:8px; border-bottom:1px solid var(--border); display:grid; grid-template-columns:40px 1fr 40px; align-items:center; }
  .month-title{ text-align:center; font-weight:800; font-size:var(--title); }
  .month-grid{
    display:grid; grid-template-columns: repeat(7, 1fr);
    grid-auto-rows: 1fr; height:100%;
  }
  .day-tile{
    border-right:1px solid var(--border); border-bottom:1px solid var(--border);
    padding:6px; position:relative; background:#fff;
  }
  .day-tile .num{
    position:absolute; top:6px; right:6px; font-size:12px; font-weight:800;
  }
  .muted{ color:#94A3B8; }

  /* Tap overlay (16 items stack) */
  .overlay{
    position:fixed; inset:0; display:none; z-index:var(--z-overlay);
    background:rgba(0,0,0,0.45);  /* dim everything underneath */
  }
  .overlay.show{ display:block; }
  .overlay .stack{
    position:absolute; left:50%; top:50%; transform:translate(-50%,-50%);
    width:min(92vw, 420px); max-height:min(90vh, 640px);
    display:flex; flex-direction:column; gap:6px; padding:8px;
    /* IMPORTANT: items themselves are opaque (no translucency) */
  }
  .task-item{
    display:flex; align-items:center; justify-content:space-between;
    background:#fff; border:1px solid var(--border); border-radius:10px; padding:10px 12px; font-weight:800; cursor:pointer;
  }
  .task-item .dur{ font-weight:800; color:#0F172A; opacity:.8; margin-left:10px; white-space:nowrap; }
  .task-item .name{ overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }

  /* Settings modal (editor) */
  .settings{
    position:fixed; inset:0; display:none; z-index:var(--z-settings);
    background:rgba(0,0,0,0.50); backdrop-filter: blur(2px);
  }
  .settings.show{ display:block; }
  .card{
    position:absolute; left:50%; top:50%; transform:translate(-50%,-50%);
    width:min(92vw, 520px); max-height:min(92vh, 720px);
    background:#fff; border:1px solid var(--border); border-radius:12px;
    display:flex; flex-direction:column; overflow:hidden;
  }
  .card-head{
    padding:12px; font-weight:900; border-bottom:1px solid var(--border); text-align:center;
  }
  .card-body{
    padding:12px; overflow:auto; display:flex; flex-direction:column; gap:12px;
  }

  .day-row{
    border:1px solid var(--border); border-radius:10px; padding:10px; display:flex; flex-direction:column; gap:10px;
  }
  .day-row .dayname{ font-weight:900; }

  .slots{ display:flex; flex-direction:column; gap:8px; }
  .slot{
    display:flex; flex-direction:column; gap:6px; border:1px dashed #CBD5E1; border-radius:8px; padding:8px;
  }
  .time-row{
    display:grid; grid-template-columns: 1fr 1fr auto; gap:8px; align-items:center;
  }
  .time-row input[type="time"]{
    width:100%; padding:8px; border:1px solid #CBD5E1; border-radius:8px; font:inherit;
  }
  .icon-btn{
    width:36px; height:36px; display:grid; place-items:center;
    border:1px solid #CBD5E1; border-radius:8px; background:#F8FAFC; cursor:pointer;
  }
  .opt-row{
    display:grid; grid-template-columns: 1fr 1fr 1fr; gap:8px; align-items:center;
  }
  .opt-row select{
    width:100%; padding:8px; border:1px solid #CBD5E1; border-radius:8px; background:#fff; font:inherit;
  }
  .add-btn{
    width:140px; align-self:flex-start;
    padding:8px 10px; border:1px solid #CBD5E1; border-radius:8px; background:#F1F5F9; cursor:pointer; font-weight:800;
  }

  .card-foot{
    display:flex; justify-content:space-between; gap:10px;
    padding:12px; border-top:1px solid var(--border);
  }
  .btn{
    padding:10px 14px; border:1px solid var(--border); border-radius:10px; background:#F8FAFC; cursor:pointer; font-weight:800;
  }
  .btn.save{ background:#0EA5E9; color:#fff; border-color:#0EA5E9; }

  /* Utility */
  .hidden{ display:none !important; }
</style>
</head>
<body>
  <main class="app">
    <section class="center" id="center">
      <!-- WEEK VIEW -->
      <div id="weekView" class="view">
        <div class="header">
          <div class="chev"><button id="prevWeek"><span class="icon">â—€</span></button></div>
          <div class="title" id="weekTitle"></div>
          <div class="chev"><button id="nextWeek"><span class="icon">â–¶</span></button></div>
        </div>

        <div class="week-wrap">
          <!-- Day labels row (NO bounding boxes; centered above columns; includes date numbers) -->
          <div class="dow-bar" id="dowBar">
            <div class="spacer"></div>
            <div class="dow" data-col="0"></div>
            <div class="dow" data-col="1"></div>
            <div class="dow" data-col="2"></div>
            <div class="dow" data-col="3"></div>
            <div class="dow" data-col="4"></div>
            <div class="dow" data-col="5"></div>
            <div class="dow" data-col="6"></div>
          </div>

          <div class="chart" id="weekChart">
            <div class="hours-col" id="weekHours"></div>
            <div class="grid" id="weekGrid"></div>
            <div class="blocks" id="weekBlocks"></div>
          </div>
        </div>
      </div>

      <!-- DAY VIEW -->
      <div id="dayView" class="view">
        <div class="day-header">
          <div class="day-title" id="dayTitle"></div>
        </div>
        <div class="day-wrap">
          <div class="chart" id="dayChart">
            <div class="hours-col" id="dayHours"></div>
            <div class="grid" id="dayGrid"></div>
            <div class="blocks" id="dayBlocks"></div>
          </div>
        </div>
      </div>

      <!-- MONTH VIEW -->
      <div id="monthView" class="view">
        <div class="month-header">
          <div class="chev"><button id="prevMonth"><span class="icon">â—€</span></button></div>
          <div class="month-title" id="monthTitle"></div>
          <div class="chev"><button id="nextMonth"><span class="icon">â–¶</span></button></div>
        </div>
        <div class="month-wrap">
          <div class="month-grid" id="monthGrid"></div>
        </div>
      </div>
    </section>

    <!-- Dock -->
    <nav class="dock" id="dock">
      <button class="pill" data-view="week" aria-pressed="false" title="Week">W</button>
      <button class="pill" data-view="day" aria-pressed="false" title="Day">D</button>
      <button class="pill" data-view="month" aria-pressed="false" title="Month">M</button>
      <button class="pill" data-view="todo" aria-pressed="false" title="To-Do">âœ“</button>
    </nav>
  </main>

  <!-- 16-item stack overlay (opaque items, dimmed background; click-away closes) -->
  <div class="overlay" id="taskOverlay">
    <div class="stack" id="taskStack"></div>
  </div>

  <!-- Settings editor -->
  <div class="settings" id="settingsOverlay" aria-modal="true" role="dialog">
    <div class="card" role="document">
      <div class="card-head">Edit Item</div>
      <div class="card-body" id="editorDays"></div>
      <div class="card-foot">
        <button class="btn" id="cancelBtn">Cancel</button>
        <button class="btn save" id="saveBtn">Save</button>
      </div>
    </div>
  </div>

<script>
/* ============================================================
   Data Model + Persistence + Sync
   ============================================================ */

/* Tasks (16 items, fixed order) */
const TASKS = [
  "Work","Commute","Chores","Errands","Meal Time","Hygiene","Self Care","Exercise",
  "Family Time","Hobbies","Projects","School","Relaxation","Free Time","Child Care","Sleep"
];

/* Color palette default (user can adjust later; stored per task) */
const DEFAULT_COLORS = {
  "Work":"#D33C36","Commute":"#E86A13","Chores":"#3B41C5","Errands":"#1D8F2E",
  "Meal Time":"#E0B21B","Hygiene":"#0EA5E9","Self Care":"#A3A3A3","Exercise":"#1DB954",
  "Family Time":"#E3326B","Hobbies":"#F39C12","Projects":"#2B90D9","School":"#3269E6",
  "Relaxation":"#24C3D6","Free Time":"#77C043","Child Care":"#7A5C2E","Sleep":"#6AA6FF"
};

/* State schema (offline-first) */
let STATE = {
  version: 1,
  deviceId: null,
  updatedAt: 0,
  etag: null,               // from server
  labels: {...Object.fromEntries(TASKS.map(t=>[t,t]))},  // editable labels (future)
  colors: {...DEFAULT_COLORS},
  EXACT: Object.fromEntries(TASKS.map(t=>[t, Array.from({length:7},()=>[])])), // recurring template (7 days)
  EXCEPTIONS: { byWeek:{}, byMonth:{}, byDate:{} },   // overrides
  ORDER: { recurring:{}, week:{}, month:{} },         // first-writer-wins order
  REMINDERS: {},                                      // per range id -> reminder
  FIRMNESS: {},                                       // per range id -> 'flex'|'firm'
};

/* Range object = { id, startMin, endMin, updatedAt } (start/end rounded to 15m) */
const SLOTS_PER_DAY = 96;

/* Local persistence: IndexedDB (primary) + localStorage mirror */
const DB_NAME = 'scheduler-db';
const STORE_STATE = 'state';
const STORE_OUTBOX = 'outbox';
let idb = null;

/* Utils */
const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
const round15=(min)=>Math.round(min/15)*15;
const minsToSlot=(min)=>clamp(Math.round(min/15),0,96);
const pad2 = n => String(n).padStart(2,'0');
const fmtISOdate = d => `${d.getFullYear()}-${pad2(d.getMonth()+1)}-${pad2(d.getDate())}`;
const fmtMonthKey = d => `${d.getFullYear()}-${pad2(d.getMonth()+1)}`;
const weekStart = (d)=>{ const x=new Date(d); x.setDate(x.getDate()-x.getDay()); x.setHours(0,0,0,0); return x; };
const addDays=(d,n)=>{ const x=new Date(d); x.setDate(x.getDate()+n); return x; };
const dayNameLong = ['Sunday','Monday','Tuesday','Wednesday','Thursday','Friday','Saturday'];
const dayNameShort = ['Sun','Mon','Tue','Wed','Thu','Fri','Sat'];

/* Very small IndexedDB helper */
function openDB(){
  return new Promise((resolve,reject)=>{
    const req = indexedDB.open(DB_NAME, 1);
    req.onupgradeneeded = (e)=>{
      const db = e.target.result;
      if(!db.objectStoreNames.contains(STORE_STATE)) db.createObjectStore(STORE_STATE);
      if(!db.objectStoreNames.contains(STORE_OUTBOX)) db.createObjectStore(STORE_OUTBOX, {keyPath:'id'});
    };
    req.onsuccess = ()=>resolve(req.result);
    req.onerror = ()=>reject(req.error);
  });
}
async function idbGet(store,key){
  return new Promise((res,rej)=>{
    const tx=idb.transaction(store,'readonly'); const st=tx.objectStore(store);
    const rq=st.get(key); rq.onsuccess=()=>res(rq.result); rq.onerror=()=>rej(rq.error);
  });
}
async function idbPut(store,key,val){
  return new Promise((res,rej)=>{
    const tx=idb.transaction(store,'readwrite'); const st=tx.objectStore(store);
    const rq = (store===STORE_STATE)? st.put(val, key) : st.put(val);
    rq.onsuccess=()=>res(true); rq.onerror=()=>rej(rq.error);
  });
}
async function idbDel(store,key){
  return new Promise((res,rej)=>{
    const tx=idb.transaction(store,'readwrite'); const st=tx.objectStore(store);
    const rq=st.delete(key); rq.onsuccess=()=>res(true); rq.onerror=()=>rej(rq.error);
  });
}
async function idbAll(store){
  return new Promise((res,rej)=>{
    const tx=idb.transaction(store,'readonly'); const st=tx.objectStore(store);
    const out=[]; const rq=st.openCursor();
    rq.onsuccess=()=>{ const c=rq.result; if(c){ out.push(c.value); c.continue(); } else res(out); };
    rq.onerror=()=>rej(rq.error);
  });
}

/* Local load/Save snapshot */
async function loadSnapshot(){
  try{
    idb = await openDB();
  }catch{}
  // try IDB
  try{
    const snap = await idbGet(STORE_STATE, 'current');
    if(snap){ STATE = snap; return; }
  }catch{}
  // fallback localStorage
  const str = localStorage.getItem('scheduleState');
  if(str){ try{ STATE = JSON.parse(str); }catch{} }
  if(!STATE.deviceId) STATE.deviceId = crypto.randomUUID?.() || String(Math.random());
}

async function saveSnapshot(){
  STATE.updatedAt = Date.now();
  try{ await idbPut(STORE_STATE,'current',STATE); }catch{}
  try{ localStorage.setItem('scheduleState', JSON.stringify(STATE)); }catch{}
  // enqueue outbox mutation (UPSERT_STATE â€” we keep it simple: send full state snapshot)
  try{
    await idbPut(STORE_OUTBOX, null, {id: `op-${STATE.updatedAt}-${Math.random()}`, op:'UPSERT_STATE', payload:STATE, ts:STATE.updatedAt});
  }catch{}
  trySync(); // fire-and-forget
}

/* Online sync (placeholder endpoints) */
const API_BASE = '/api/schedule';
async function trySync(){
  if(!navigator.onLine) return;
  try{
    // Load server etag / state
    const head = await fetch(API_BASE, {method:'GET'});
    if(!head.ok) return;
    const etag = head.headers.get('ETag');
    let server = null;
    try{ server = await head.json(); }catch{}

    // If server newer â†’ merge down
    if(server && server.updatedAt && server.updatedAt > (STATE.updatedAt||0)){
      const merged = mergeStates(server, STATE);
      STATE = merged;
      await idbPut(STORE_STATE,'current',STATE);
      localStorage.setItem('scheduleState', JSON.stringify(STATE));
    }

    // Push outbox
    const ops = await idbAll(STORE_OUTBOX);
    if(ops.length){
      // For simplicity, PUT full snapshot (last op wins locally)
      const last = ops.sort((a,b)=>a.ts-b.ts)[ops.length-1];
      const put = await fetch(API_BASE, {
        method:'PUT',
        headers: {'Content-Type':'application/json', ...(etag?{'If-Match':etag}:{}) },
        body: JSON.stringify(last.payload)
      });
      if(put.ok){
        const newE = put.headers.get('ETag');
        STATE.etag = newE || null;
        // clear outbox
        for(const op of ops){ await idbDel(STORE_OUTBOX, op.id); }
        await idbPut(STORE_STATE,'current',STATE);
        localStorage.setItem('scheduleState', JSON.stringify(STATE));
      }
    }
  }catch(e){ /* ignore */ }
}
window.addEventListener('online', trySync);

/* Merge rule: range-level LWW, firm beats flex on conflicts of same updatedAt */
function mergeStates(server, local){
  if(!server || !server.version) return local;
  if(!local || !local.version) return server;
  const out = JSON.parse(JSON.stringify(server)); // start from server
  // if local is newer, prefer local piecewise
  if((local.updatedAt||0) <= (server.updatedAt||0)) return out;

  // Piecewise merge (labels/colors)
  out.labels = {...server.labels, ...local.labels};
  out.colors = {...server.colors, ...local.colors};

  // Merge EXACT/EXCEPTIONS by range id
  function mergeExact(exS, exL){
    const res = Array.from({length:7},()=>[]);
    for(let d=0; d<7; d++){
      const byId = new Map();
      (exS[d]||[]).forEach(r=>byId.set(r.id, r));
      (exL[d]||[]).forEach(r=>{
        const s = byId.get(r.id);
        if(!s || (r.updatedAt||0) > (s.updatedAt||0)) byId.set(r.id, r);
        else if(s.updatedAt===r.updatedAt){
          // tie-breaker doesn't matter much; keep server
        }
      });
      res[d] = [...byId.values()];
    }
    return res;
  }

  out.EXACT = Object.fromEntries(TASKS.map(t=>{
    const s = server.EXACT?.[t]||Array.from({length:7},()=>[]);
    const l = local.EXACT?.[t] || Array.from({length:7},()=>[]);
    return [t, mergeExact(s,l)];
  }));

  // byWeek / byMonth / byDate
  out.EXCEPTIONS = { byWeek:{}, byMonth:{}, byDate:{} };
  function mergeScoped(sMap, lMap){
    const keys = new Set([...Object.keys(sMap||{}), ...Object.keys(lMap||{})]);
    const outMap = {};
    for(const k of keys){
      outMap[k] = Object.fromEntries(TASKS.map(t=>{
        const s = sMap?.[k]?.[t] || Array.from({length:7},()=>[]);
        const l = lMap?.[k]?.[t] || Array.from({length:7},()=>[]);
        return [t, mergeExact(s,l)];
      }));
    }
    return outMap;
  }
  out.EXCEPTIONS.byWeek = mergeScoped(server.EXCEPTIONS?.byWeek||{}, local.EXCEPTIONS?.byWeek||{});
  out.EXCEPTIONS.byMonth= mergeScoped(server.EXCEPTIONS?.byMonth||{}, local.EXCEPTIONS?.byMonth||{});
  out.EXCEPTIONS.byDate = {};
  const dateKeys=new Set([...Object.keys(server.EXCEPTIONS?.byDate||{}), ...Object.keys(local.EXCEPTIONS?.byDate||{})]);
  for(const dk of dateKeys){
    out.EXCEPTIONS.byDate[dk] = Object.fromEntries(TASKS.map(t=>{
      const s = server.EXCEPTIONS?.byDate?.[dk]?.[t] || [];
      const l = local.EXCEPTIONS?.byDate?.[dk]?.[t] || [];
      const byId = new Map();
      s.forEach(r=>byId.set(r.id,r));
      l.forEach(r=>{
        const prev = byId.get(r.id);
        if(!prev || (r.updatedAt||0) > (prev.updatedAt||0)) byId.set(r.id, r);
      });
      return [t,[...byId.values()]];
    }));
  }

  // Merge reminders/firmness by range id
  out.REMINDERS = {...server.REMINDERS, ...local.REMINDERS};
  out.FIRMNESS  = {...server.FIRMNESS,  ...local.FIRMNESS};

  // ORDER: take earliest known writes per scope
  out.ORDER = {...server.ORDER};
  out.ORDER.recurring = {...server.ORDER?.recurring, ...local.ORDER?.recurring};
  out.ORDER.week = {...server.ORDER?.week, ...local.ORDER?.week};
  out.ORDER.month= {...server.ORDER?.month, ...local.ORDER?.month};

  out.updatedAt = local.updatedAt;
  return out;
}

/* ============================================================
   Rendering (Week / Day / Month)
   ============================================================ */

const center = document.getElementById('center');
const weekView = document.getElementById('weekView');
const dayView = document.getElementById('dayView');
const monthView = document.getElementById('monthView');
const dock = document.getElementById('dock');

const weekTitle = document.getElementById('weekTitle');
const dowBar = document.getElementById('dowBar');
const weekHours = document.getElementById('weekHours');
const weekGrid = document.getElementById('weekGrid');
const weekBlocks = document.getElementById('weekBlocks');

const dayTitle = document.getElementById('dayTitle');
const dayHours = document.getElementById('dayHours');
const dayGrid = document.getElementById('dayGrid');
const dayBlocks = document.getElementById('dayBlocks');

const monthTitle = document.getElementById('monthTitle');
const monthGrid = document.getElementById('monthGrid');

let visibleWeekStart = weekStart(new Date());   // Sunday
let visibleDay = new Date(visibleWeekStart);    // mirrors week selection
let visibleMonth = new Date(visibleWeekStart.getFullYear(), visibleWeekStart.getMonth(), 1);

function fmtWeekTitle(first){
  const last = addDays(first,6);
  const m = new Intl.DateTimeFormat(undefined,{month:'short'});
  if(first.getFullYear()===last.getFullYear()){
    if(first.getMonth()===last.getMonth()){
      return `${m.format(first)} ${first.getDate()} â€“ ${last.getDate()}, ${first.getFullYear()}`;
    }
    return `${m.format(first)} ${first.getDate()} â€“ ${m.format(last)} ${last.getDate()}, ${first.getFullYear()}`;
  }
  return `${m.format(first)} ${first.getDate()}, ${first.getFullYear()} â€“ ${m.format(last)} ${last.getDate()}, ${last.getFullYear()}`;
}

function buildHourCols(hoursEl, gridEl, isDay=false){
  hoursEl.innerHTML=''; gridEl.innerHTML='';
  const H = gridEl.getBoundingClientRect().height || (center.getBoundingClientRect().height - 40);
  // 24 hours rows with 15-min sublines
  for(let h=0; h<24; h++){
    const top = (H/24)*h;
    const mid = top + (H/24)/2;
    // hour label
    const lab = document.createElement('div');
    lab.className='hour-label';
    lab.style.top = `${mid}px`;
    lab.textContent = `${pad2(h)}:00`;
    hoursEl.appendChild(lab);

    // hour line
    const hr = document.createElement('div');
    hr.className='hour';
    hr.style.top = `${top}px`;
    gridEl.appendChild(hr);

    // quarter lines
    for(let q=1;q<4;q++){
      const qy = top + (H/24)*q/4;
      const ql = document.createElement('div');
      ql.className='q';
      ql.style.top = `${qy}px`;
      gridEl.appendChild(ql);
    }
  }
}

function buildWeek(){
  // Titles
  weekTitle.textContent = fmtWeekTitle(visibleWeekStart);

  // Day labels (Sun, 31; Mon, 1, ...)
  const first = new Date(visibleWeekStart);
  for(let i=0;i<7;i++){
    const el = dowBar.querySelector(`.dow[data-col="${i}"]`);
    const d = addDays(first,i);
    el.textContent = `${dayNameShort[d.getDay()]}, ${d.getDate()}`;
  }

  // Clear + draw grid/labels
  buildHourCols(weekHours, weekGrid);

  // Paint blocks from effective week
  paintWeekBlocks();
}

function computeWeekGeom(){
  const chart = document.getElementById('weekChart');
  const r = chart.getBoundingClientRect();
  const totalW = Math.max(0, r.width - parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--hour-col')));
  const totalH = r.height;

  // 7 columns equal width (fill remainder)
  const colW = Math.floor(totalW/7);
  const extra = totalW - colW*7;
  const x = [0];
  for(let i=0;i<7;i++){ x.push(x[i] + colW + (i<extra?1:0)); }

  // slot Y positions for 96 ticks
  const slotY=[0]; const perHour=totalH/24;
  for(let h=0;h<24;h++){
    for(let q=1;q<=4;q++){
      slotY.push(Math.round((h + q/4)*perHour));
    }
  }
  return {x, totalH, totalW: r.width, slotY};
}

function paintWeekBlocks(){
  weekBlocks.innerHTML='';
  const {x, slotY} = computeWeekGeom();
  const eff = computeEffectiveWeek();

  for(let d=0; d<7; d++){
    // Merge contiguous slots for each task
    const segments = compressDaySlots(eff[d]);
    for(const seg of segments){
      if(!seg.cat) continue;
      const left = x[d];
      const right = x[d+1] - (d===6 ? 1 : 0);
      const top = slotY[seg.a];
      const bottom = slotY[seg.b];
      const div = document.createElement('div');
      div.className='blk';
      div.style.left = (parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--hour-col')) + left) + 'px';
      div.style.top = top+'px';
      div.style.width = Math.max(0,right-left)+'px';
      div.style.height = Math.max(0,bottom-top)+'px';
      div.style.background = STATE.colors[seg.cat] || '#99AABB';
      weekBlocks.appendChild(div);
    }
  }
}

/* Day view: clone a single day column stretched full width */
function buildDay(){
  const d = new Date(visibleDay);
  // title like "Wednesday, Sep 3, 2025"
  dayTitle.textContent = d.toLocaleDateString(undefined,{weekday:'long', year:'numeric', month:'short', day:'numeric'});
  buildHourCols(dayHours, dayGrid, true);

  dayBlocks.innerHTML='';
  const chart = document.getElementById('dayChart');
  const r = chart.getBoundingClientRect();
  const totalW = r.width - parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--hour-col'));
  const totalH = r.height;

  // Slot Y
  const slotY=[0]; const perHour=totalH/24;
  for(let h=0;h<24;h++){
    for(let q=1;q<=4;q++){
      slotY.push(Math.round((h + q/4)*perHour));
    }
  }
  // Effective week, then pick today's column
  const eff = computeEffectiveWeek();
  const dow = d.getDay();
  const segments = compressDaySlots(eff[dow]);
  for(const seg of segments){
    if(!seg.cat) continue;
    const left = 0, right = totalW - 1;
    const top = slotY[seg.a];
    const bottom = slotY[seg.b];
    const div = document.createElement('div');
    div.className='blk';
    div.style.left = (parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--hour-col')) + left) + 'px';
    div.style.top = top+'px';
    div.style.width = Math.max(0,right-left)+'px';
    div.style.height = Math.max(0,bottom-top)+'px';
    div.style.background = STATE.colors[seg.cat] || '#99AABB';
    dayBlocks.appendChild(div);
  }
}

/* Month view (full tiles; prev/next month days in gray; tiles fill to bottom) */
function buildMonth(){
  const y = visibleMonth.getFullYear();
  const m = visibleMonth.getMonth();
  monthTitle.textContent = visibleMonth.toLocaleDateString(undefined,{month:'long', year:'numeric'});

  monthGrid.innerHTML = '';
  const first = new Date(y,m,1);
  const firstDow = first.getDay(); // 0..6
  const daysInMonth = new Date(y,m+1,0).getDate();
  const prevDays = new Date(y,m,0).getDate();

  // 6 rows * 7 cols = 42 tiles
  for(let i=0;i<42;i++){
    const tile = document.createElement('div');
    tile.className='day-tile';
    let dayNum, muted=false, dateObj;
    if(i<firstDow){
      dayNum = prevDays - firstDow + i + 1; muted = true;
      dateObj = new Date(y, m-1, dayNum);
    } else if(i >= firstDow + daysInMonth){
      dayNum = i - (firstDow + daysInMonth) + 1; muted = true;
      dateObj = new Date(y, m+1, dayNum);
    } else {
      dayNum = i - firstDow + 1; muted = false;
      dateObj = new Date(y, m, dayNum);
    }
    const num = document.createElement('div');
    num.className = 'num' + (muted?' muted':'');
    num.textContent = dayNum;
    tile.appendChild(num);
    monthGrid.appendChild(tile);
  }
}

/* ============================================================
   Effective Week Computation & Painting
   ============================================================ */

/* Build occupancy for visible week (first-writer-wins) */
function computeEffectiveWeek(){
  // Initialize empty week (7 x 96 null)
  const week = Array.from({length:7},()=>Array(SLOTS_PER_DAY).fill(null));
  const wkKey = fmtISOdate(visibleWeekStart);
  const moKey = fmtMonthKey(visibleWeekStart);

  // Determine sequence for ordering
  const seqForTask = (task)=>{
    const seqs = [
      STATE.ORDER.week?.[wkKey]?.[task],
      STATE.ORDER.month?.[moKey]?.[task],
      STATE.ORDER.recurring?.[task]
    ].filter(n=>typeof n==='number');
    return seqs.length? Math.min(...seqs) : 1e9;
  };

  const ordered = [...TASKS].sort((a,b)=>seqForTask(a)-seqForTask(b));

  for(const task of ordered){
    // start with recurring
    let eff = deepCopyWeek(STATE.EXACT[task]||Array.from({length:7},()=>[]));

    // month override
    if(STATE.EXCEPTIONS.byMonth?.[moKey]?.[task]){
      eff = deepCopyWeek(STATE.EXCEPTIONS.byMonth[moKey][task]);
    }
    // week override
    if(STATE.EXCEPTIONS.byWeek?.[wkKey]?.[task]){
      eff = deepCopyWeek(STATE.EXCEPTIONS.byWeek[wkKey][task]);
    }
    // day overrides (byDate)
    for(let d=0; d<7; d++){
      const dateKey = fmtISOdate(addDays(visibleWeekStart, d));
      if(STATE.EXCEPTIONS.byDate?.[dateKey]?.[task]){
        eff[d] = deepCopyRanges(STATE.EXCEPTIONS.byDate[dateKey][task]);
      }
    }

    // Paint on empty slots only
    for(let d=0; d<7; d++){
      for(const r of eff[d]||[]){
        let a = minsToSlot(round15(r.startMin));
        let b = minsToSlot(round15(r.endMin));
        if(b===a) continue;
        if(b>a){
          for(let s=a;s<b;s++) if(week[d][s]===null) week[d][s]=task;
        }else{
          for(let s=a;s<96;s++) if(week[d][s]===null) week[d][s]=task;
          const dn=(d+1)%7;
          for(let s=0;s<b;s++) if(week[dn][s]===null) week[dn][s]=task;
        }
      }
    }
  }
  return week;
}

function compressDaySlots(dayArr){
  const out=[];
  let s=0;
  while(s<96){
    const cat = dayArr[s];
    if(cat===null){ s++; continue; }
    let e=s+1;
    while(e<96 && dayArr[e]===cat) e++;
    out.push({cat, a:s, b:e});
    s=e;
  }
  return out;
}

function deepCopyWeek(w){ return w.map(day => day.map(r=>({...r}))); }
function deepCopyRanges(arr){ return arr.map(r=>({...r})); }

/* Duration for a task in CURRENTLY VIEWED week */
function weeklyMinutesFor(task){
  const eff = computeEffectiveWeek();
  let count=0;
  for(let d=0; d<7; d++){
    for(let s=0; s<96; s++){
      if(eff[d][s]===task) count++;
    }
  }
  return count*15;
}
function fmtDuration(min){
  if(min<=0) return '';
  if(min<60) return `${min}m`;
  const h = Math.floor(min/60);
  const rem = min - h*60;
  return rem ? `${h}h ${rem}m` : `${h}h`;
}

/* ============================================================
   Overlay (16 items) + Editor (ranges)
   ============================================================ */

const taskOverlay = document.getElementById('taskOverlay');
const taskStack = document.getElementById('taskStack');
const settingsOverlay = document.getElementById('settingsOverlay');
const editorDays = document.getElementById('editorDays');
const cancelBtn = document.getElementById('cancelBtn');
const saveBtn = document.getElementById('saveBtn');

let currentTask = null;            // string
let editorScope = 'recurring';     // default per-slot UI uses selects; we save per-slot scope
let SAVE_SEQ = 1;

/* Open overlay when chart tapped (week/day both open same stack) */
document.getElementById('weekChart').addEventListener('click', openTaskStack);
document.getElementById('dayChart').addEventListener('click', openTaskStack);
function openTaskStack(){
  taskStack.innerHTML='';
  // ensure all 16 fit (tight vertical spacing)
  TASKS.forEach((t)=>{
    const btn = document.createElement('div');
    btn.className='task-item';
    const dur = fmtDuration(weeklyMinutesFor(t));
    btn.innerHTML = `<span class="name">${STATE.labels[t]||t}</span><span class="dur">${dur}</span>`;
    btn.addEventListener('click', ()=>{ currentTask = t; taskOverlay.classList.remove('show'); openEditor(t); });
    taskStack.appendChild(btn);
  });
  taskOverlay.classList.add('show');
}
taskOverlay.addEventListener('click', (e)=>{ if(e.target===taskOverlay) taskOverlay.classList.remove('show'); });

/* Editor: one section per day (Sunday, August 31st, etc.) */
function openEditor(task){
  editorDays.innerHTML='';
  const base = new Date(visibleWeekStart); // full dates reflect the week being viewed

  for(let d=0; d<7; d++){
    const date = addDays(base, d);
    const full = date.toLocaleDateString(undefined,{weekday:'long', month:'long', day:'numeric', year:'numeric'});
    const row = document.createElement('div');
    row.className = 'day-row';
    row.dataset.day = d;
    row.innerHTML = `
      <div class="dayname">${full}</div>
      <div class="slots"></div>
      <button class="add-btn" type="button">Create New</button>
    `;
    const slots = row.querySelector('.slots');
    const addBtn = row.querySelector('.add-btn');
    addBtn.addEventListener('click', ()=> addSlot(slots));
    editorDays.appendChild(row);
  }

  settingsOverlay.classList.add('show');
}

/* Create a blank slot row (no prefilling) */
function addSlot(container){
  if(container.children.length>=6) return;
  const slot = document.createElement('div');
  slot.className='slot';
  slot.innerHTML = `
    <div class="time-row">
      <input type="time" class="t-start" step="60" placeholder="Start">
      <input type="time" class="t-end" step="60" placeholder="End">
      <div style="display:flex;gap:6px;">
        <button class="icon-btn mic" title="Speak time">ðŸŽ¤</button>
        <button class="icon-btn del" title="Delete">ðŸ—‘</button>
      </div>
    </div>
    <div class="opt-row">
      <select class="scope">
        <option value="recurring" selected>Recurring</option>
        <option value="week">This week</option>
        <option value="month">This month</option>
      </select>
      <select class="reminder">
        <option value="" selected>Set reminder</option>
        <option value="5m">5 minutes</option>
        <option value="10m">10 minutes</option>
        <option value="15m">15 minutes</option>
        <option value="30m">30 minutes</option>
        <option value="1h">1 hour</option>
        <option value="24h">24 hours</option>
      </select>
      <select class="firm">
        <option value="flex" selected>Flexible</option>
        <option value="firm">Firm</option>
      </select>
    </div>
  `;
  slot.querySelector('.del').addEventListener('click', ()=>slot.remove());
  slot.querySelector('.mic').addEventListener('click', ()=>voiceFill(slot));
  container.appendChild(slot);
}

/* Basic speech â†’ time parser ("9 am to 5 pm") */
function voiceFill(slot){
  const startEl = slot.querySelector('.t-start');
  const endEl = slot.querySelector('.t-end');
  if(!('webkitSpeechRecognition' in window || 'SpeechRecognition' in window)){
    alert('Speech not supported on this device.');
    return;
  }
  const Rec = window.SpeechRecognition || window.webkitSpeechRecognition;
  const rec = new Rec();
  rec.lang = 'en-US';
  rec.interimResults = false;
  rec.maxAlternatives = 1;
  rec.onresult = (e)=>{
    const txt = (e.results[0][0].transcript || '').toLowerCase();
    // naive parse: "<h[:mm]> (am|pm) to <h[:mm]> (am|pm)"
    const m = txt.match(/(\d{1,2})(?::(\d{2}))?\s*(am|pm)?\s*(?:to|\-|through|till)\s*(\d{1,2})(?::(\d{2}))?\s*(am|pm)?/);
    if(m){
      const sH = parseInt(m[1],10); const sM = m[2]?parseInt(m[2],10):0; const sAMPM = m[3]||'';
      const eH = parseInt(m[4],10); const eM = m[5]?parseInt(m[5],10):0; const eAMPM = m[6]||'';
      const s24 = to24(sH,sM,sAMPM); const e24 = to24(eH,eM,eAMPM);
      startEl.value = `${pad2(s24.h)}:${pad2(s24.m)}`;
      endEl.value   = `${pad2(e24.h)}:${pad2(e24.m)}`;
    }else{
      alert('Could not parse. Try: "9:00 am to 5:00 pm".');
    }
  };
  rec.start();
}
function to24(h,m,ampm){
  h = clamp(h,1,12);
  if(ampm==='pm' && h<12) h+=12;
  if(ampm==='am' && h===12) h=0;
  return {h,m};
}

/* Cancel â†’ confirm discard */
cancelBtn.addEventListener('click', ()=>{
  if(confirm('Are you sure you want to delete these edits (this session only)?')){
    settingsOverlay.classList.remove('show');
  }
});

/* Save: collect all day ranges â†’ normalize â†’ persist by scope */
saveBtn.addEventListener('click', ()=>{
  if(!currentTask){ settingsOverlay.classList.remove('show'); return; }

  const collected = Array.from({length:7},()=>[]);
  const base = new Date(visibleWeekStart);

  editorDays.querySelectorAll('.day-row').forEach((row)=>{
    const d = parseInt(row.dataset.day,10);
    row.querySelectorAll('.slot').forEach((slot)=>{
      const sVal = slot.querySelector('.t-start').value;
      const eVal = slot.querySelector('.t-end').value;
      if(!sVal || !eVal) return; // ignore blank
      const [sh,sm] = sVal.split(':').map(Number);
      const [eh,em] = eVal.split(':').map(Number);
      const sMin = sh*60 + sm;
      const eMin = eh*60 + em;

      const scope = slot.querySelector('.scope').value;      // recurring | week | month
      const rem   = slot.querySelector('.reminder').value;   // '', '5m', '10m', ...
      const firm  = slot.querySelector('.firm').value;       // 'flex' | 'firm'

      // Normalize â†’ split overnight first, then round
      function pushRange(dayIdx, a,b){
        a = round15(a); b = round15(b);
        if(b<=a) return;
        const id=`${currentTask}-${fmtISOdate(addDays(base,dayIdx))}-${a}-${b}-${Math.random().toString(36).slice(2,8)}`;
        collected[dayIdx].push({id, startMin:a, endMin:b, updatedAt:Date.now(), scope, rem, firm});
      }

      if(eMin > sMin){
        pushRange(d, sMin, eMin);
      }else if(eMin < sMin){
        // overnight split
        pushRange(d, sMin, 1440);
        pushRange((d+1)%7, 0, eMin);
      } // equal ignored
    });
  });

  // Apply to STATE according to per-slot scope
  const wkKey = fmtISOdate(visibleWeekStart);
  const moKey = fmtMonthKey(visibleWeekStart);

  function ensureWeekTemplate(arr){ return Array.from({length:7},(_,i)=> Array.isArray(arr?.[i]) ? arr[i] : []); }

  // Start by cloning current effective per-scope storages for this task
  const exact = ensureWeekTemplate(STATE.EXACT[currentTask]);
  const wExc  = STATE.EXCEPTIONS.byWeek[wkKey]?.[currentTask] ? ensureWeekTemplate(STATE.EXCEPTIONS.byWeek[wkKey][currentTask]) : ensureWeekTemplate(null);
  const mExc  = STATE.EXCEPTIONS.byMonth[moKey]?.[currentTask]? ensureWeekTemplate(STATE.EXCEPTIONS.byMonth[moKey][currentTask]) : ensureWeekTemplate(null);

  // We'll replace days that were edited for a given scope (not merge into old ones), to reflect session intent.
  const editedDayByScope = {recurring:new Set(), week:new Set(), month:new Set()};
  for(let d=0; d<7; d++){
    for(const r of collected[d]){
      editedDayByScope[r.scope].add(d);
    }
  }

  function setDay(scope, dayIdx, ranges){
    const dest = (scope==='recurring') ? exact : (scope==='week'? wExc : mExc);
    dest[dayIdx] = ranges.map(({id,startMin,endMin,updatedAt,rem,firm})=>{
      // persist reminder/firmness by id
      if(rem)  STATE.REMINDERS[id]=rem; else delete STATE.REMINDERS[id];
      STATE.FIRMNESS[id] = (firm==='firm'?'firm':'flex');
      return {id,startMin,endMin,updatedAt};
    });
  }

  for(let d=0; d<7; d++){
    // For each scope that touched this day, set that scope's day to ONLY the new ranges of that scope from collected.
    ['recurring','week','month'].forEach(sc=>{
      if(editedDayByScope[sc].has(d)){
        setDay(sc, d, collected[d].filter(r=>r.scope===sc));
      }
    });
  }

  // Write back storages
  STATE.EXACT[currentTask] = exact;
  if(editedDayByScope.week.size){
    STATE.EXCEPTIONS.byWeek[wkKey] = STATE.EXCEPTIONS.byWeek[wkKey] || {};
    STATE.EXCEPTIONS.byWeek[wkKey][currentTask] = wExc;
  }
  if(editedDayByScope.month.size){
    STATE.EXCEPTIONS.byMonth[moKey] = STATE.EXCEPTIONS.byMonth[moKey] || {};
    STATE.EXCEPTIONS.byMonth[moKey][currentTask] = mExc;
  }

  // ORDER (first-writer wins) â€” assign sequence ids if new
  if(editedDayByScope.recurring.size){
    if(!STATE.ORDER.recurring[currentTask]) STATE.ORDER.recurring[currentTask] = SAVE_SEQ++;
  }
  if(editedDayByScope.week.size){
    STATE.ORDER.week[wkKey] = STATE.ORDER.week[wkKey] || {};
    if(!STATE.ORDER.week[wkKey][currentTask]) STATE.ORDER.week[wkKey][currentTask] = SAVE_SEQ++;
  }
  if(editedDayByScope.month.size){
    STATE.ORDER.month[moKey] = STATE.ORDER.month[moKey] || {};
    if(!STATE.ORDER.month[moKey][currentTask]) STATE.ORDER.month[moKey][currentTask] = SAVE_SEQ++;
  }

  // Repaint current week/day with new data
  paintWeekBlocks();
  buildDay();

  // Persist (offline + enqueue sync)
  saveSnapshot();

  // Close editor
  settingsOverlay.classList.remove('show');
});

/* ============================================================
   View Switching / Navigation
   ============================================================ */
let activeView = null; // none on load

dock.querySelectorAll('.pill').forEach(btn=>{
  btn.addEventListener('click', ()=>{
    const v = btn.dataset.view;
    if(activeView===v){
      // deactivate
      activeView = null;
      setActiveView(null);
      return;
    }
    activeView = v;
    setActiveView(v);
  });
});

function setActiveView(v){
  dock.querySelectorAll('.pill').forEach(b=>{
    const on = b.dataset.view===v;
    b.classList.toggle('active', on);
    b.setAttribute('aria-pressed', on?'true':'false');
  });
  weekView.classList.toggle('active', v==='week');
  dayView.classList.toggle('active', v==='day');
  monthView.classList.toggle('active', v==='month');
  // 'todo' is a placeholder â€” no view

  if(v==='week'){ buildWeek(); }
  if(v==='day'){ buildDay(); }
  if(v==='month'){ buildMonth(); }
}

/* Week chevrons */
document.getElementById('prevWeek').addEventListener('click', ()=>{
  visibleWeekStart = addDays(visibleWeekStart, -7);
  // keep day in sync (same weekday)
  visibleDay = addDays(visibleDay, -7);
  buildWeek(); buildDay();
});
document.getElementById('nextWeek').addEventListener('click', ()=>{
  visibleWeekStart = addDays(visibleWeekStart, +7);
  visibleDay = addDays(visibleDay, +7);
  buildWeek(); buildDay();
});

/* Month chevrons */
document.getElementById('prevMonth').addEventListener('click', ()=>{
  visibleMonth = new Date(visibleMonth.getFullYear(), visibleMonth.getMonth()-1, 1);
  buildMonth();
});
document.getElementById('nextMonth').addEventListener('click', ()=>{
  visibleMonth = new Date(visibleMonth.getFullYear(), visibleMonth.getMonth()+1, 1);
  buildMonth();
});

/* ============================================================
   Boot
   ============================================================ */
(async function boot(){
  await loadSnapshot();
  // No prefill â€” STATE is empty unless user saved before.
  // Start with no active view; user chooses.
  // However, we need initial geometry; build once for each when first opened.
  // Also set day to today for Day view.
  visibleDay = new Date();

  // Resize observer to rebuild grids if size changes
  const ro = new ResizeObserver(()=>{
    if(activeView==='week') buildWeek();
    if(activeView==='day') buildDay();
    if(activeView==='month') buildMonth();
  });
  ro.observe(center);

  // Attempt initial sync (if online); otherwise we just use local state
  trySync();
})();
</script>
</body>
</html>