<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Chrono â€” r82 (Week-only test build)</title>
<meta name="theme-color" content="#000000">
<link rel="manifest" href="manifest.webmanifest">
<style>
  :root{
    --bg:#e3eaf2; --ink:#42586d;
    --icon-inactive:#42586d; --icon-active:#4ff7ff;
    --pressed-navy:#355169; --turq-glow: rgba(79,247,255,.75);

    --off:5px; --blur:9px; --hi:#ffffff; --lo:#b7c3d1;
    --gap:24px; --radius:12px;

    --border:#c6cfda; --grid-line:#cfd9e5;
    --chart-bg:#d1dce8; --mask-surface: var(--bg);

    --dow-h:32px; --label-size:12px;

    --stamp-gap:6px; --stamp-h:26px;
    --handle-height-mult:1.6;
    --handle-gap:10px;
    --chev-stroke-w:2.2;
    --handle-stroke:#5e7286;

    --neu-shadow-outer:
      calc(-1*var(--off)) calc(-1*var(--off)) var(--blur) var(--hi),
       var(--off)         var(--off)         var(--blur) var(--lo);
    --neu-shadow-inner:
       inset calc(-1*var(--off)) calc(-1*var(--off)) var(--blur) var(--hi),
       inset var(--off)         var(--off)         var(--blur) var(--lo);
    --neu-offset-shadow: 8px 10px 20px rgba(0,0,0,.22);
  }
  html,body{
    height:100%; margin:0; background:var(--bg); color:var(--ink);
    font:500 16px/1.4 system-ui,-apple-system,"Segoe UI",Roboto,Arial,sans-serif; overflow:hidden;
    -webkit-tap-highlight-color: transparent;
  }
  *{ box-sizing:border-box; }

  .app{
    width:clamp(320px, 96vw, 520px);
    height:calc(100svh - max(16px, env(safe-area-inset-top)) - max(16px, env(safe-area-inset-bottom)));
    margin:max(16px, env(safe-area-inset-top)) auto;
    display:flex; flex-direction:column; gap:var(--gap); padding:0 var(--gap);
  }

  #screen{
    flex:1; min-height:420px; border-radius:var(--radius); background:var(--bg);
    box-shadow: var(--neu-shadow-outer);
    position:relative; overflow:hidden;
  }

  .controls{ display:flex; gap:var(--gap); padding-bottom:2px; }
  .neu-btn{
    --btn-d: calc((100% - (3 * var(--gap))) / 4);
    flex:0 0 var(--btn-d); width:var(--btn-d); aspect-ratio:1/1;
    border-radius:50%; border:none; outline:none; cursor:pointer;
    background:var(--bg); display:grid; place-items:center;
    box-shadow: var(--neu-shadow-outer);
    transition: box-shadow .2s ease, background .2s ease, transform .06s ease;
  }
  .neu-btn svg{
    width:86%; height:auto; stroke:var(--icon-inactive); stroke-width:1.25;
    fill:none; stroke-linecap:round; stroke-linejoin:round;
    filter: drop-shadow(-0.6px -0.6px 0 var(--hi)) drop-shadow(0.6px 0.6px 0 var(--lo));
  }
  .neu-btn.is-pressed{
    background:
      radial-gradient(circle at 82% 82%, rgba(79,247,255,.12) 0%, rgba(79,247,255,.07) 34%, rgba(79,247,255,0) 60%),
      var(--pressed-navy);
    box-shadow:
       var(--off)         var(--off)         var(--blur) var(--hi),
      calc(-1*var(--off)) calc(-1*var(--off)) var(--blur) var(--lo);
  }
  .neu-btn.is-pressed svg{ stroke:var(--icon-active); filter:drop-shadow(0 0 2px var(--turq-glow)) drop-shadow(0 0 10px var(--turq-glow)); }
  .neu-btn:active{ transform:scale(.985); }

  .wrap{ position:absolute; inset:0; display:grid; grid-template-rows:auto 1fr; min-width:0 }
  .head{ display:grid; grid-template-columns:auto 1fr auto; align-items:center; gap:8px; padding:8px 10px; }
  .title{ text-align:center; font-weight:800; font-size:16px; min-width:0; overflow:hidden; text-overflow:ellipsis; white-space:nowrap }

  .grid-area{ position:relative; }
  .grid{
    position:absolute; top:var(--dow-h); left:0; right:0; bottom:0;
    background:var(--chart-bg);
    border-left:1px solid var(--grid-line); border-right:1px solid var(--grid-line);
  }
  .top-row{ position:absolute; top:0; left:0; right:0; height:var(--dow-h); display:grid; align-items:center; grid-template-columns:repeat(7,1fr); column-gap:8px; padding:0 6px }
  .day-pill{ justify-self:center; border:none; padding:0 2px; text-align:center; font-size:clamp(11px, 2vw, 13px); background:transparent; color:var(--ink) }
  .hours{ position:absolute; top:var(--dow-h); bottom:0; left:0; width:60px; pointer-events:none; z-index:0 }
  .hour-stamp{ position:absolute; right:8px; transform:translateY(-50%); font-size:var(--label-size); color:var(--ink); opacity:.95; white-space:nowrap; text-align:right; }

  .blocksHost{ position:absolute; inset:0; pointer-events:auto; z-index:0; }
  .blockRect{ position:absolute; border-radius:10px; border:none; cursor:pointer; }

  /* Fixed overlay that is never clipped by the grid */
  #overlayRoot{ position:fixed; inset:0; pointer-events:none; z-index:999; }
  .overlayLayer{ position:absolute; pointer-events:none; }
  .marqueeRect, .focusRect{
    position:absolute; box-sizing:border-box; background:transparent;
    border:5px solid #fff; border-radius:12px;
  }
  .marqueeRect{ box-shadow: 0 0 12px 6px rgba(79,247,255,.75); }
  .focusRect{ box-shadow:none; }

  .stamp{
    position:absolute; left:50%; transform:translateX(-50%);
    background:var(--pressed-navy); color:var(--icon-active);
    border:1px solid #273b4d; border-radius:10px; padding:4px 8px;
    font-size:12px; font-variant-numeric:tabular-nums; font-weight:900; letter-spacing:.02em; white-space:nowrap;
    pointer-events:none; height:var(--stamp-h); display:grid; place-items:center;
    box-shadow: 0 0 2px rgba(79,247,255,.35), 0 0 10px rgba(79,247,255,.35);
  }

  .handle{ position:absolute; left:0; width:100%; cursor:ns-resize; touch-action:none; display:grid; place-items:center;
           pointer-events:auto; /* allow interaction even though overlayRoot disables it */ }
  .chev-chip{
    width:100%; height:100%; border-radius:14px;
    background:var(--bg);
    box-shadow: var(--neu-shadow-outer);
    display:grid; place-items:center;
  }
  .chev path{
    fill:none; stroke:var(--handle-stroke); stroke-width:var(--chev-stroke-w); stroke-linecap:round; stroke-linejoin:round;
    filter: drop-shadow(-0.6px -0.6px 0 var(--hi)) drop-shadow(0.6px 0.6px 0 var(--lo));
  }

  .selBtns{ position:fixed; z-index:1000; display:grid; gap:8px; pointer-events:auto; }
  .neu-btn--sm{ width:44px; height:44px; border-radius:12px; background:var(--bg); border:none; cursor:pointer; box-shadow:var(--neu-shadow-outer); display:grid; place-items:center; transition:background .15s ease; }
  .neu-btn--sm svg{ width:22px; height:22px; stroke:var(--icon-inactive); stroke-width:1.25; fill:none; stroke-linecap:round; stroke-linejoin:round; filter: drop-shadow(-0.6px -0.6px 0 var(--hi)) drop-shadow(0.6px 0.6px 0 var(--lo)); }

  .veil{ position:fixed; inset:0; background:rgba(0,0,0,.25); z-index:1100; }
  .modal{
    position:fixed; left:50%; top:50%; transform:translate(-50%,-50%);
    width:min(92vw, 360px); background:var(--bg); color:var(--ink);
    border-radius:12px; box-shadow: var(--neu-shadow-outer), var(--neu-offset-shadow); z-index:1110;
    display:grid; grid-template-rows:auto 1fr auto; max-height:88vh; overflow:hidden;
  }
  .modal .head{ padding:12px 14px; font-weight:800; background:var(--bg); box-shadow: var(--neu-shadow-inner); display:flex; align-items:center; justify-content:center; }
  .modal .foot{ padding:10px 14px; display:flex; justify-content:space-between; gap:10px; background:var(--bg); box-shadow:var(--neu-shadow-inner); }
  .btn{ border:none; background:var(--bg); border-radius:10px; padding:10px 14px; font-weight:800; cursor:pointer; box-shadow:var(--neu-shadow-outer); }
  .settings-wrap{ padding:14px; display:grid; gap:14px; overflow:auto; }
  .neu-field{ background:var(--bg); border-radius:12px; padding:10px; box-shadow:var(--neu-shadow-inner); display:grid; gap:8px; }
  .neu-select{ display:flex; align-items:center; justify-content:space-between; gap:10px; padding:10px 12px; border-radius:12px; background:var(--bg); box-shadow:var(--neu-shadow-outer); cursor:pointer; user-select:none; }
  .neu-menu{ display:none; }
  .neu-menu.open{ display:block; }
  .menu-card{ margin-top:8px; background:var(--bg); border-radius:12px; box-shadow:var(--neu-shadow-outer); overflow:hidden; }
  .menu-item{ padding:10px 12px; cursor:pointer; display:flex; align-items:center; gap:10px; }
  .menu-item:not(:last-child){ border-bottom:1px solid var(--grid-line); }

  .screensaver{ position:absolute; inset:0; display:grid; place-items:center; color:#667a90 }
  .screensaver .wm{ opacity:.8; font-weight:900; letter-spacing:.06em; }
</style>
</head>
<body>
  <main class="app">
    <section id="screen" aria-live="polite" aria-label="Content area"></section>

    <nav class="controls" role="group" aria-label="Primary views">
      <button class="neu-btn" aria-label="Day view (disabled)" data-view="day" title="Day (disabled)">
        <svg viewBox="0 0 24 24" aria-hidden="true">
          <circle cx="12" cy="12" r="5.5"/>
          <line x1="12" y1="2"  x2="12" y2="5"/>
          <line x1="12" y1="19" x2="12" y2="22"/>
          <line x1="2"  y1="12" x2="5"  y2="12"/>
          <line x1="19" y1="12" x2="22" y2="12"/>
          <line x1="17" y1="7"  x2="19" y2="5"/>
          <line x1="7"  y1="17" x2="5"  y2="19"/>
          <line x1="7"  y1="7"  x2="5"  y2="5"/>
          <line x1="17" y1="17" x2="19" y2="19"/>
        </svg>
      </button>

      <button class="neu-btn is-pressed" aria-label="Week view" aria-pressed="true" data-view="week" title="Week">
        <svg viewBox="0 0 24 24" aria-hidden="true">
          <rect x="3" y="4.5" width="18" height="15" rx="3"/>
          <line x1="3" y1="8" x2="21" y2="8"/>
          <line x1="6" y1="10" x2="6" y2="18.5"/>
          <line x1="9" y1="10" x2="9" y2="18.5"/>
          <line x1="12" y1="10" x2="12" y2="18.5"/>
          <line x1="15" y1="10" x2="15" y2="18.5"/>
          <line x1="18" y1="10" x2="18" y2="18.5"/>
        </svg>
      </button>

      <button class="neu-btn" aria-label="Month view (disabled)" data-view="month" title="Month (disabled)">
        <svg viewBox="0 0 24 24" aria-hidden="true">
          <rect x="3" y="4.5" width="18" height="15" rx="3"/>
          <line x1="3" y1="8" x2="21" y2="8"/>
          <g>
            <circle cx="7" cy="11" r="0.8"/><circle cx="11" cy="11" r="0.8"/><circle cx="15" cy="11" r="0.8"/>
            <circle cx="7" cy="14" r="0.8"/><circle cx="11" cy="14" r="0.8"/><circle cx="15" cy="14" r="0.8"/>
            <circle cx="7" cy="17" r="0.8"/><circle cx="11" cy="17" r="0.8"/><circle cx="15" cy="17" r="0.8"/>
          </g>
        </svg>
      </button>

      <button class="neu-btn" aria-label="To-Do (disabled)" data-view="todo" title="To-Do (disabled)">
        <svg viewBox="0 0 24 24" aria-hidden="true">
          <rect x="4" y="5" width="16" height="14" rx="3"/>
          <line x1="4" y1="8" x2="20" y2="8"/>
          <polyline points="7,14 10,17 17,10"/>
        </svg>
      </button>
    </nav>
  </main>

  <div id="overlayRoot" aria-hidden="true"></div>

<script>
/* Chrono r82 â€” week-only test build focusing on selector overlay + spillover integrity */

const screenEl = document.getElementById('screen');
const overlayRoot = document.getElementById('overlayRoot');
const buttons = [...document.querySelectorAll('.neu-btn')];

let activeView = 'week';
let visibleWeekFirst = weekStart(new Date());

const SHORT_DOW=['Sun','Mon','Tue','Wed','Thu','Fri','Sat'];
const MONTH_INIT=['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];

function weekStart(d){ const x=new Date(d.getFullYear(), d.getMonth(), d.getDate()); const dow=x.getDay(); x.setDate(x.getDate()-dow); x.setHours(0,0,0,0); return x; }
function addDays(d,n){ const x=new Date(d); x.setDate(x.getDate()+n); return x; }
function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }
function snap15(n){ return 15 * Math.round((+n||0)/15); }
function hourToAMPM(h){ return h===0? '12 AM' : h<12? `${h} AM` : h===12? '12 PM' : `${h-12} PM`; }
function HHMM_24(min){ const m=((Math.round(min)|0)+1440)%1440; const h=Math.floor(m/60), r=m%60; return `${String(h).padStart(2,'0')}:${String(r).padStart(2,'0')}`; }

const DAY_MS = 86400000;
function weekStamp(d){ return +weekStart(d); }
function stampToDate(st){ return new Date(st); }
function getVisibleWeekStamp(){ return weekStamp(visibleWeekFirst); }

/* storage */
const DB_NAME='chronoDB', DB_VERSION=34;
let dbPromise=null, STORAGE_MODE='idb';
function idbSupported(){ try { return !!window.indexedDB; } catch { return false; } }
function idbOpen(){
  if(!idbSupported()){ STORAGE_MODE='ls'; return Promise.resolve(null); }
  if(dbPromise) return dbPromise;
  dbPromise = new Promise((resolve,reject)=>{
    const req = indexedDB.open(DB_NAME, DB_VERSION);
    req.onupgradeneeded = ()=>{
      const db = req.result;
      if(!db.objectStoreNames.contains('kv')) db.createObjectStore('kv',{keyPath:'k'});
      if(!db.objectStoreNames.contains('blocks')) db.createObjectStore('blocks',{keyPath:'id'});
    };
    req.onsuccess = ()=>resolve(req.result);
    req.onerror   = ()=>reject(req.error);
  });
  return dbPromise.catch(()=>{ STORAGE_MODE='ls'; return null; });
}
async function storageSet(k,v){
  if(STORAGE_MODE==='ls'){ if(v===undefined) localStorage.removeItem(k); else localStorage.setItem(k, JSON.stringify(v)); return true; }
  const db = await idbOpen(); if(!db){ STORAGE_MODE='ls'; return storageSet(k,v); }
  return new Promise((res,rej)=>{
    const tx=db.transaction('kv','readwrite');
    const store=tx.objectStore('kv');
    if(v===undefined) store.delete(k); else store.put({k,v});
    tx.oncomplete=()=>res(true); tx.onerror = ()=>rej(tx.error);
  });
}
async function storageGet(k){
  if(STORAGE_MODE==='ls'){ const s=localStorage.getItem(k); return s? JSON.parse(s):undefined; }
  const db = await idbOpen(); if(!db){ STORAGE_MODE='ls'; return storageGet(k); }
  return new Promise((res,rej)=>{
    const tx=db.transaction('kv','readonly');
    const req=tx.objectStore('kv').get(k);
    req.onsuccess=()=>res(req.result? req.result.v:undefined);
    req.onerror=()=>rej(req.error);
  });
}

/* block store */
async function putBlock(b){
  const db = await idbOpen(); if(!db) return;
  return new Promise((res,rej)=>{
    const tx=db.transaction('blocks','readwrite');
    tx.objectStore('blocks').put(b);
    tx.oncomplete=()=>res(true); tx.onerror=()=>rej(tx.error);
  });
}
async function delBlock(id){
  const db = await idbOpen(); if(!db) return;
  return new Promise((res,rej)=>{
    const tx=db.transaction('blocks','readwrite');
    tx.objectStore('blocks').delete(id);
    tx.oncomplete=()=>res(true); tx.onerror=()=>rej(tx.error);
  });
}
async function getBlocksAll(){
  const db = await idbOpen(); if(!db) return [];
  return new Promise((res,rej)=>{
    const tx=db.transaction('blocks','readonly');
    const req=tx.objectStore('blocks').getAll();
    req.onsuccess=()=>res(req.result||[]);
    req.onerror=()=>rej(req.error);
  });
}

/* colors/activities */
const COLORS = ['#F7D6D0','#D6EEF5','#BFD9CF','#F7E08C','#E77D7A','#4EA1D6','#4FA684','#E5B21A','#E3423A','#1E6FB6','#187245','#D79516','#7F1D2D','#0E3B5C','#0A3A34','#C1730D'];
const ACTIVITY_LIST = [
  {key:'work', label:'Work',       color: COLORS[8]},
  {key:'school', label:'School',   color: COLORS[9]},
  {key:'commute', label:'Commute', color: COLORS[7]},
  {key:'chores', label:'Chores',   color: COLORS[4]},
  {key:'errands', label:'Errands', color: COLORS[11]},
  {key:'meal', label:'Meal Time',  color: COLORS[3]},
  {key:'hygiene', label:'Hygiene', color: COLORS[1]},
  {key:'childcare', label:'Child Care', color: COLORS[12]},
  {key:'selfcare', label:'Self Care',   color: COLORS[6]},
  {key:'exercise', label:'Exercise',    color: COLORS[10]},
  {key:'family', label:'Family Time',   color: COLORS[15]},
  {key:'hobbies', label:'Hobbies',      color: COLORS[14]},
  {key:'projects', label:'Projects',    color: COLORS[13]},
  {key:'rr', label:'R & R',             color: COLORS[2]},
  {key:'free', label:'Free Time',       color: COLORS[0]},
  {key:'sleep', label:'Sleep',          color: COLORS[9]}
];
function getActivityByKey(k){ return ACTIVITY_LIST.find(a=>a.key===k) || ACTIVITY_LIST[0]; }

/* geometry */
let gridGeom=null;
function measureGrid(){
  const grid = document.getElementById('weekGrid');
  if(!grid) return;
  const r=grid.getBoundingClientRect();
  const totalW=Math.max(0, Math.round(r.width));
  const totalH=Math.max(0, Math.round(r.height));
  const colWBase=Math.floor(totalW/7), extraW=totalW-colWBase*7;
  const colW=[], colX=[0]; for(let c=0;c<7;c++){ const w=colWBase+(c<extraW?1:0); colW.push(w); colX.push(colX[c]+w); }
  const rowHBase=Math.floor(totalH/24), extraH=totalH-rowHBase*24;
  const rowH=[], rowY=[0]; for(let i=0;i<24;i++){ const h=rowHBase+(i<extraH?1:0); rowH.push(h); rowY.push(rowY[i]+h); }
  const slotY=[0]; for(let hr=0;hr<24;hr++){ const h=rowH[hr]; const base=Math.floor(h/4); let rem=h-base*4; const parts=[base,base,base,base]; for(let k=0;k<rem;k++) parts[k]+=1; for(let q=0;q<4;q++) slotY.push(slotY[slotY.length-1]+parts[q]); }
  gridGeom={rect:r,totalW,totalH,colW,colX,rowH,rowY,slotY};
}
function idxFromMin(min){ return clamp(Math.round(min/15), 0, 96); }
function boundsFromSeg(seg){
  const colLeft = gridGeom.colX[seg.dayIdx];
  const colRight= gridGeom.colX[seg.dayIdx+1];
  const colWidth= (colRight - colLeft) - (seg.dayIdx===6?1:0);
  const idx = idxFromMin(seg.startMin);
  const idx2= idxFromMin(seg.endMin);
  const topY  = gridGeom.slotY[idx];
  const botY  = gridGeom.slotY[idx2];
  const height= Math.max(1, botY - topY);
  return {offsetLeft:colLeft, colWidth, topY, botY, height};
}

/* week view build */
function buildWeekView(){
  screenEl.innerHTML = `
    <div class="wrap">
      <div class="head">
        <button id="prevWeekBtn" class="neu-btn--sm" title="Previous">&#9664;</button>
        <div class="title" id="weekTitle"></div>
        <button id="nextWeekBtn" class="neu-btn--sm" title="Next">&#9654;</button>
      </div>

      <div class="grid-area">
        <div class="top-row" id="dowPills"></div>
        <div class="grid" id="weekGrid" aria-label="Weekly grid" role="grid">
          <div class="blocksHost" id="blocksHost"></div>
        </div>
        <div class="hours" id="weekHours"></div>
      </div>
    </div>
  `;
  document.getElementById('prevWeekBtn').onclick = async ()=>{ if(_modalOpen) return; visibleWeekFirst=addDays(visibleWeekFirst,-7); repaintWeek(true); };
  document.getElementById('nextWeekBtn').onclick = async ()=>{ if(_modalOpen) return; visibleWeekFirst=addDays(visibleWeekFirst, 7); repaintWeek(true); };

  const grid = document.getElementById('weekGrid');
  grid.addEventListener('click', onWeekGridTap);
  new ResizeObserver(()=>{ measureGrid(); drawBlocks(); drawOverlay(); positionSelectorButtons(); }).observe(grid);

  repaintWeek();
  drawBlocks();
}

/* top row + hours + title */
function repaintWeek(){
  const first=visibleWeekFirst, last=addDays(first,6);
  document.getElementById('weekTitle').textContent = `${MONTH_INIT[first.getMonth()]} ${first.getDate()} â€“ ${MONTH_INIT[last.getMonth()]} ${last.getDate()}`;

  const pills=document.getElementById('dowPills'); pills.innerHTML='';
  for(let i=0;i<7;i++){ const el=document.createElement('div'); el.className='day-pill'; el.textContent = SHORT_DOW[i]; pills.appendChild(el); }

  const gh=document.getElementById('weekHours'); gh.innerHTML='';
  measureGrid();
  for(let i=0;i<24;i++){
    const s=document.createElement('div'); s.className='hour-stamp';
    s.textContent = hourToAMPM(i);
    s.style.top=((gridGeom.rowY[i]+gridGeom.rowY[i+1])/2)+'px';
    gh.appendChild(s);
  }
}

/* blocks render */
async function getInstancesForWeek(allBlocks){
  const wst = getVisibleWeekStamp();
  const instances = [];
  for(const b of allBlocks){
    if(b.recurrence==='none'){ if(b.weekSt===wst) instances.push(b); }
    else if(b.recurrence==='weekly'){ if(wst>=b.weekSt) instances.push({...b, weekSt:wst}); }
    else if(b.recurrence==='monthly'){ if(b.weekSt===wst) instances.push(b); }
  }
  return instances;
}
async function drawBlocks(){
  const host=document.getElementById('blocksHost'); if(!host || !gridGeom) return;
  host.innerHTML='';
  const blocks = await getBlocksAll();
  const inst = await getInstancesForWeek(blocks);
  for(const seg of inst){
    const b=boundsFromSeg(seg);
    const el=document.createElement('div');
    el.className='blockRect';
    el.dataset.id = seg.id;
    el.dataset.groupId = seg.groupId || '';
    el.style.left = `${b.offsetLeft}px`;
    el.style.top = `${b.topY}px`;
    el.style.width = `${b.colWidth}px`;
    el.style.height = `${b.height}px`;
    el.style.background = seg.colorHex || getActivityByKey(seg.activityKey)?.color || '#E3423A';
    el.addEventListener('click', (ev)=>{ ev.stopPropagation(); clearSelector(); selectBlock(seg); });
    host.appendChild(el);
  }
}

/* busy windows + helpers */
function sortByStart(a,b){ return a.startMin - b.startMin; }
function sameWeekDay(seg, weekSt, dayIdx){ return seg.weekSt===weekSt && seg.dayIdx===dayIdx; }
async function dayBusyIntervals(weekSt, dayIdx, excludeGroupIdOrId=null){
  const all = await getBlocksAll();
  const instances = await getInstancesForWeek(all);
  const list = instances
    .filter(b => sameWeekDay(b, weekSt, dayIdx) && (!excludeGroupIdOrId || (b.groupId||b.id)!==excludeGroupIdOrId))
    .map(b => ({startMin:b.startMin, endMin:b.endMin}));
  list.sort(sortByStart);
  const merged=[];
  for(const it of list){
    if(!merged.length || it.startMin>merged[merged.length-1].endMin){ merged.push({...it}); }
    else { merged[merged.length-1].endMin = Math.max(merged[merged.length-1].endMin, it.endMin); }
  }
  return merged;
}
function clampToFreeWindow(start, end, busy){
  let s = clamp(start, 0, 1440-15);
  let e = clamp(end, s+15, 1440);
  for(const b of busy){
    if(s>=b.startMin && e<=b.endMin){ s = b.endMin; e = Math.max(s+15, e); }
    if(s < b.endMin && s >= b.startMin && e > b.endMin){ s = b.endMin; }
    if(e > b.startMin && e <= b.endMin && s < b.startMin){ e = b.startMin; }
    if(s < b.startMin && e > b.endMin){
      if(b.startMin - s >= 15){ e = b.startMin; }
      else { s = b.endMin; }
    }
    s = clamp(s, 0, 1440-15);
    e = clamp(e, s+15, 1440);
  }
  return {start:s, end:e};
}
function largestFreeStartingAt(atMin, busy, minLen=15){
  const free=[]; let prev=0;
  for(const b of busy){ if(b.startMin>prev) free.push({s:prev, e:b.startMin}); prev=Math.max(prev,b.endMin); }
  if(prev<1440) free.push({s:prev, e:1440});
  for(const f of free){
    const s = Math.max(atMin, f.s);
    const len = f.e - s;
    if(len>=minLen) return {start:s, end:s+len};
  }
  return null;
}

/* overlay drawing */
function clearOverlay(){ overlayRoot.replaceChildren(); }
function overlayGroup(){ const g=document.createElement('div'); g.className='overlayLayer'; overlayRoot.appendChild(g); return g; }

/* selector state */
let chain=null; // { parent:{weekSt,dayIdx,startMin,endMin}, child:{...}|null }
let selected=null;
let _modalOpen=false;

function onWeekGridTap(e){
  if(_modalOpen) return;
  if(!gridGeom) return;
  const rect = gridGeom.rect;
  const relX = e.clientX - rect.left;
  const relY = e.clientY - rect.top;
  let dayIdx=0; for(let i=0;i<7;i++){ if(relX >= gridGeom.colX[i] && relX < gridGeom.colX[i+1]){ dayIdx=i; break; } }
  const minuteFloat = clamp(relY / gridGeom.totalH, 0, 1) * 1440;
  let startMin = snap15(Math.floor(minuteFloat/60)*60);
  let endMin   = clamp(startMin + 60, 0, 1440);
  dayBusyIntervals(getVisibleWeekStamp(), dayIdx, null).then(busy=>{
    const fit = largestFreeStartingAt(startMin, busy, 15);
    if(!fit){ clearSelector(); return; }
    endMin = Math.min(fit.start + 60, fit.end);
    if(endMin - fit.start < 15){ clearSelector(); return; }
    chain = { parent: { weekSt:getVisibleWeekStamp(), dayIdx, startMin:fit.start, endMin }, child: null };
    selected = null;
    drawOverlay();
    showSelectorButtons();
  });
}

/* draw selector overlay (parent + optional child) */
function chevronsSVG(dir, w, rowH){
  const padX = 8;
  const width = Math.max(24, w - padX*2);
  const h = Math.max(44, Math.floor(rowH*parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--handle-height-mult'))||1.6));
  const mid = width/2;
  const gap = h/6;
  const span = Math.min(width*0.42, h/4);
  const triUp = (y)=>`M ${mid-span} ${y+span} L ${mid} ${y} L ${mid+span} ${y+span}`;
  const triDn = (y)=>`M ${mid-span} ${y} L ${mid} ${y+span} L ${mid+span} ${y}`;
  const d1 = (dir==='up'? triUp(gap) : triDn(gap));
  const d2 = (dir==='up'? triUp(gap*2.2) : triDn(gap*2.2));
  const d3 = (dir==='up'? triUp(gap*3.4) : triDn(gap*3.4));
  return `<div class="chev"><svg width="${width}" height="${h}" viewBox="0 0 ${width} ${h}" aria-hidden="true"><path d="${d1}"/><path d="${d2}"/><path d="${d3}"/></svg></div>`;
}
function segOnThisWeek(seg){ return seg && seg.weekSt === getVisibleWeekStamp(); }

function drawOverlay(){
  clearOverlay();
  if(!gridGeom) return;
  const group = overlayGroup();

  const rowH = gridGeom.rowH[0] || 48;
  const hH = rowH * (parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--handle-height-mult'))||1.6);
  const hGap = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--handle-gap'))||10;
  const sGap = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--stamp-gap'))||6;
  const sH   = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--stamp-h'))||26;

  const renderEntry = (seg, showTop, showBottom)=>{
    const b=boundsFromSeg(seg);
    const x = gridGeom.rect.left + gridGeom.colX[seg.dayIdx];
    const y = gridGeom.rect.top + b.topY;
    const w = b.colWidth;
    const h = b.height;

    const rectEl=document.createElement('div'); rectEl.className='marqueeRect';
    rectEl.style.left = x+'px'; rectEl.style.top = y+'px'; rectEl.style.width = w+'px'; rectEl.style.height = h+'px';
    group.appendChild(rectEl);

    const container=document.createElement('div'); container.style.position='absolute';
    container.style.left=x+'px'; container.style.top=y+'px'; container.style.width=w+'px'; container.style.height=h+'px';
    group.appendChild(container);

    if(showTop){
      const topStamp=document.createElement('div'); topStamp.className='stamp';
      topStamp.textContent = HHMM_24(seg.startMin);
      topStamp.style.left = (w/2)+'px';
      topStamp.style.top  = (- (sGap + sH))+'px';
      container.appendChild(topStamp);

      const topHandle=document.createElement('div'); topHandle.className='handle top';
      topHandle.style.left='0px'; topHandle.style.top = (- (sGap + sH + hGap + hH))+'px';
      topHandle.style.width=w+'px'; topHandle.style.height=hH+'px';
      topHandle.innerHTML = `<div class="chev-chip">${chevronsSVG('up', w, rowH)}</div>`;
      topHandle.addEventListener('pointerdown', ev=>startDrag(ev,'top', seg), {passive:false});
      container.appendChild(topHandle);
    }
    if(showBottom){
      const botStamp=document.createElement('div'); botStamp.className='stamp';
      botStamp.textContent = HHMM_24(seg.endMin);
      botStamp.style.left = (w/2)+'px';
      botStamp.style.top  = (h + sGap)+'px';
      container.appendChild(botStamp);

      const botHandle=document.createElement('div'); botHandle.className='handle bottom';
      botHandle.style.left='0px'; botHandle.style.top = (h + sGap + sH + hGap)+'px';
      botHandle.style.width=w+'px'; botHandle.style.height=hH+'px';
      botHandle.innerHTML = `<div class="chev-chip">${chevronsSVG('down', w, rowH)}</div>`;
      botHandle.addEventListener('pointerdown', ev=>startDrag(ev,'bottom', seg), {passive:false});
      container.appendChild(botHandle);
    }
  };

  const pHere = segOnThisWeek(chain?.parent);
  const cHere = segOnThisWeek(chain?.child);

  if(chain && pHere && !cHere){ renderEntry(chain.parent,true,true); }
  else if(chain && !pHere && cHere){ renderEntry(chain.child,true,true); }
  else if(chain && pHere && cHere){
    renderEntry(chain.parent,true,false);
    renderEntry(chain.child,false,true);
  }

  if(selected){
    const b=boundsFromSeg(selected);
    const x = gridGeom.rect.left + gridGeom.colX[selected.dayIdx];
    const y = gridGeom.rect.top + b.topY;
    const w = b.colWidth, h = b.height;
    const rectEl=document.createElement('div'); rectEl.className='focusRect';
    rectEl.style.left = x+'px'; rectEl.style.top = y+'px'; rectEl.style.width = w+'px'; rectEl.style.height = h+'px';
    group.appendChild(rectEl);
  }
}

/* selector interactions */
let dragKind=null, dragSeg=null, dragStartY=0, baseStart=0, baseEnd=0;
function startDrag(ev, kind, seg){
  if(!chain) return;
  ev.preventDefault(); ev.stopPropagation();
  ev.currentTarget.setPointerCapture(ev.pointerId);
  dragKind=kind; dragSeg=seg; dragStartY=ev.clientY; baseStart=seg.startMin; baseEnd=seg.endMin;

  const move=async (e)=>{
    if(!gridGeom || !dragSeg) return;
    const dyPx = e.clientY - dragStartY;
    const movedMin = (gridGeom.totalH? (dyPx / gridGeom.totalH) * 1440 : 0);
    const snappedDelta = snap15(movedMin);

    const isParent = dragSeg===chain.parent;
    const isChild  = chain.child && dragSeg===chain.child;

    if(isParent){
      if(kind==='top'){
        let newStart = clamp(baseStart + snappedDelta, 0, chain.parent.endMin - 15);
        const busy = await dayBusyIntervals(chain.parent.weekSt, chain.parent.dayIdx, null);
        const c = clampToFreeWindow(newStart, chain.parent.endMin, busy);
        chain.parent.startMin = Math.min(c.start, chain.parent.endMin-15);
      }else{ // bottom on parent allowed only if no child yet
        if(!chain.child){
          let newEnd = clamp(baseEnd + snappedDelta, chain.parent.startMin+15, 1440);
          const busy = await dayBusyIntervals(chain.parent.weekSt, chain.parent.dayIdx, null);
          const c = clampToFreeWindow(chain.parent.startMin, newEnd, busy);
          chain.parent.endMin = Math.max(c.end, chain.parent.startMin+15);
          if(chain.parent.endMin>=1440){ spilloverConfirm('next'); }
        }
      }
    }else if(isChild){
      if(kind==='bottom'){
        let newEnd = clamp(baseEnd + snappedDelta, chain.child.startMin+15, 1440);
        const busy = await dayBusyIntervals(chain.child.weekSt, chain.child.dayIdx, null);
        const c = clampToFreeWindow(chain.child.startMin, newEnd, busy);
        chain.child.endMin = Math.max(c.end, chain.child.startMin+15);
      } // top on child is anchored at 0 â†’ ignore
    }
    drawOverlay();
  };
  const up=(e)=>{
    e.currentTarget.releasePointerCapture(e.pointerId);
    window.removeEventListener('pointermove', move);
    window.removeEventListener('pointerup', up);
    dragKind=null; dragSeg=null;
  };
  window.addEventListener('pointermove', move, {passive:false});
  window.addEventListener('pointerup', up, {passive:true});
}

/* spillover creation */
function modalConfirm(text){
  return new Promise((resolve)=>{
    const veil=document.createElement('div'); veil.className='veil';
    const modal=document.createElement('div'); modal.className='modal';
    modal.innerHTML=`<div class="head">${text}</div><div class="settings-wrap" style="padding:16px"> </div><div class="foot"><button class="btn" data-a="no">Cancel</button><button class="btn ok" data-a="yes">OK</button></div>`;
    document.body.appendChild(veil); document.body.appendChild(modal);
    const close=(val)=>{ veil.remove(); modal.remove(); resolve(val); };
    modal.addEventListener('click', e=>{ const b=e.target.closest('button'); if(!b) return; b.dataset.a==='yes'? close(true):close(false); });
    veil.addEventListener('click', ()=>close(false));
  });
}
async function spilloverConfirm(direction){
  const ok = await modalConfirm(direction==='next'?'Spill to next day?':'Spill to previous day?');
  if(!ok) return;
  if(direction==='next'){
    const p = chain.parent;
    // clamp parent to end of day
    const busyP = await dayBusyIntervals(p.weekSt, p.dayIdx, null);
    const cP = clampToFreeWindow(p.startMin, 1440, busyP);
    p.endMin = cP.end;
    // create child next day anchored at start 0
    let childDay = (p.dayIdx<6)? p.dayIdx+1 : 0;
    let childWeek = (p.dayIdx<6)? p.weekSt : p.weekSt + 7*DAY_MS;
    const busyC = await dayBusyIntervals(childWeek, childDay, null);
    const fit = largestFreeStartingAt(0, busyC, 15);
    if(!fit){ chain.child=null; drawOverlay(); return; }
    const rem = Math.max(15, 60 - (p.endMin - p.startMin));
    chain.child = { weekSt: childWeek, dayIdx: childDay, startMin: fit.start, endMin: Math.min(1440, fit.start + rem) };
    if(p.dayIdx===6) visibleWeekFirst = stampToDate(childWeek);
    drawOverlay();
  }else{
    const p = chain.parent;
    // clamp parent to start of day
    const busyP = await dayBusyIntervals(p.weekSt, p.dayIdx, null);
    const cP = clampToFreeWindow(0, p.endMin, busyP);
    p.startMin = cP.start;
    // create child previous day anchored near 1440
    let childDay = (p.dayIdx>0)? p.dayIdx-1 : 6;
    let childWeek = (p.dayIdx>0)? p.weekSt : p.weekSt - 7*DAY_MS;
    const busyC = await dayBusyIntervals(childWeek, childDay, null);
    const free=[]; let prev=0;
    for(const b of busyC){ if(b.startMin>prev) free.push({s:prev, e:b.startMin}); prev=Math.max(prev,b.endMin); }
    if(prev<1440) free.push({s:prev, e:1440});
    const last = free.length? free[free.length-1]:null;
    if(!last){ chain.child=null; drawOverlay(); return; }
    const span = Math.max(15, 60 - (p.endMin - p.startMin));
    const end = last.e;
    const start = clamp(end - span, last.s, end-15);
    chain.child = { weekSt: childWeek, dayIdx: childDay, startMin:start, endMin:end };
    if(p.dayIdx===0) visibleWeekFirst = stampToDate(childWeek);
    drawOverlay();
  }
}

/* selector buttons */
function removeSelectorButtons(){ document.getElementById('selectorBtns')?.remove(); }
function showSelectorButtons(){
  removeSelectorButtons();
  if(!chain || !gridGeom) return;
  const seg = chain.parent;
  const b=boundsFromSeg(seg);
  const margin=8, btnW=44, totalH=(44*1)+0;
  let left = gridGeom.rect.left + gridGeom.colX[seg.dayIdx] + b.colWidth + margin;
  if(left + btnW > window.innerWidth - margin){ left = Math.max(margin, gridGeom.rect.left + gridGeom.colX[seg.dayIdx] - margin - btnW); }
  let top = gridGeom.rect.top + b.topY + (b.height/2) - (totalH/2);
  top = Math.max(margin, Math.min(window.innerHeight - margin - totalH, top));

  const wrap=document.createElement('div'); wrap.className='selBtns'; wrap.id='selectorBtns';
  const gear = document.createElement('button'); gear.className='neu-btn--sm'; gear.title='Settings';
  gear.innerHTML = `<svg viewBox="0 0 24 24" aria-hidden="true"><circle cx="12" cy="12" r="3.5" /><path d="M12 2v3M12 17v5M4.9 4.9l2.1 2.1M17 17l2.1 2.1M2 12h3M19 12h3M4.9 19.1 7 17M17 7l2.1-2.1" /></svg>`;
  gear.querySelectorAll('circle,path').forEach(n=>{ n.setAttribute('fill','none'); n.setAttribute('stroke','currentColor'); n.setAttribute('stroke-width','1.35'); n.setAttribute('stroke-linecap','round'); n.setAttribute('stroke-linejoin','round'); });
  gear.onclick = ()=> openSettingsModal();
  wrap.appendChild(gear);
  document.body.appendChild(wrap);
  wrap.style.left=`${Math.round(left)}px`; wrap.style.top=`${Math.round(top)}px`;
}

function clearSelector(){ chain=null; removeSelectorButtons(); clearOverlay(); }

/* basic settings with unified over-midnight semantics for creation only */
function hookMenu(root, selSel, menuSel, onPick){
  const trigger = root.querySelector(selSel);
  const menu = root.querySelector(menuSel);
  trigger.addEventListener('click', ()=>{ const open = menu.classList.toggle('open'); trigger.setAttribute('aria-expanded', open?'true':'false'); });
  menu.querySelectorAll('.menu-item').forEach(mi=> mi.addEventListener('click', ()=>{ onPick(mi.dataset.val, mi.textContent.trim()); menu.classList.remove('open'); trigger.setAttribute('aria-expanded','false'); }));
}

function openSettingsModal(){
  if(!chain) return;
  _modalOpen=true;
  const veil=document.createElement('div'); veil.className='veil';
  const modal=document.createElement('div'); modal.className='modal';
  const p = chain.parent, c = chain.child;
  const absStart = p.startMin;
  const absEnd = c ? 1440 + c.endMin : p.endMin;

  modal.innerHTML = `
    <div class="head">New Block</div>
    <div class="settings-wrap">
      <div class="neu-field">
        <div>Start: <strong>${HHMM_24(absStart%1440)}</strong></div>
        <div>End: <strong>${HHMM_24(absEnd%1440)}${absEnd>1440?' (+1d)':''}</strong></div>
      </div>
      <div class="neu-field">
        <div class="neu-select" id="actSel"><span>Assign Activity</span><svg viewBox="0 0 24 24"><polyline points="6,9 12,15 18,9"/></svg></div>
        <div class="neu-menu" id="actMenu"><div class="menu-card" id="actList"></div></div>
      </div>
      <div class="neu-field">
        <button class="btn" id="saveBtn">Save</button>
      </div>
    </div>
    <div class="foot"><button class="btn" id="closeBtn">Close</button></div>
  `;
  document.body.appendChild(veil); document.body.appendChild(modal);

  const listEl = modal.querySelector('#actList');
  ACTIVITY_LIST.forEach(a=>{
    const row = document.createElement('div'); row.className='menu-item'; row.dataset.key=a.key;
    row.innerHTML = `<span style="display:inline-block;width:14px;height:14px;border-radius:50%;background:${a.color}"></span><span>${a.label}</span>`;
    row.addEventListener('click', ()=>{ modal.querySelector('#actSel span').textContent = a.label; modal.dataset.actKey = a.key; modal.querySelector('#actMenu').classList.remove('open'); });
    listEl.appendChild(row);
  });
  modal.querySelector('#actSel').addEventListener('click', ()=>{ const m = modal.querySelector('#actMenu'); const open=m.classList.toggle('open'); });

  modal.querySelector('#closeBtn').onclick=()=>{ veil.remove(); modal.remove(); _modalOpen=false; };
  modal.querySelector('#saveBtn').onclick=async ()=>{
    const key = modal.dataset.actKey || 'free';
    const act = getActivityByKey(key);
    // commit as one or two blocks (storage remains split, semantics unified)
    const baseId = 'b'+Date.now();
    const firstEnd = Math.min(1440, absEnd);
    const blkA = { id: baseId, weekSt:p.weekSt, dayIdx:p.dayIdx, startMin:absStart, endMin:firstEnd, activityKey:key, activityName:act.label, colorHex:act.color, note:'', recurrence:'weekly', flexibility:'flexible', notifications:'reoccurring', privacy:'private' };
    const busyA = await dayBusyIntervals(blkA.weekSt, blkA.dayIdx, null); const cA = clampToFreeWindow(blkA.startMin, blkA.endMin, busyA); blkA.startMin=cA.start; blkA.endMin=cA.end;
    await putBlock(blkA);
    if(absEnd>1440){
      const nextDayIdx = (p.dayIdx===6)? 0 : p.dayIdx+1;
      const nextWeekSt = (p.dayIdx===6)? p.weekSt + 7*DAY_MS : p.weekSt;
      const blkB = { ...blkA, id: 'b'+(Date.now()+1), weekSt:nextWeekSt, dayIdx:nextDayIdx, startMin:0, endMin:absEnd-1440 };
      const busyB = await dayBusyIntervals(blkB.weekSt, blkB.dayIdx, null); const cB = clampToFreeWindow(blkB.startMin, blkB.endMin, busyB); blkB.startMin=cB.start; blkB.endMin=cB.end;
      await putBlock(blkB);
    }
    veil.remove(); modal.remove(); _modalOpen=false;
    chain=null; removeSelectorButtons(); drawBlocks(); clearOverlay();
  };
}

/* existing block focus (minimal) */
function selectBlock(seg){ selected={...seg}; drawOverlay(); }

/* controls */
buttons.forEach(b=>{
  b.addEventListener('click', (e)=>{
    const v=e.currentTarget.dataset.view;
    buttons.forEach(x=>{ x.classList.remove('is-pressed'); x.setAttribute('aria-pressed','false'); });
    if(v==='week'){ activeView='week'; e.currentTarget.classList.add('is-pressed'); e.currentTarget.setAttribute('aria-pressed','true'); render(); }
    else{ activeView=v; render(); }
  });
});

/* render */
function showScreensaver(){
  screenEl.innerHTML = `<div class="screensaver"><div class="wm">Chrono r82 â€” Week-only test build</div></div>`;
}
function render(){
  if(activeView==='week'){ buildWeekView(); }
  else{ showScreensaver(); }
}

/* init */
function init(){
  render();
}
init();
</script>

<!-- Service worker (optional) -->
<script>
if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('./service-worker.js')
      .then(reg => console.log('SW registered', reg.scope))
      .catch(err => console.error('SW registration failed', err));
  });
}
</script>
</body>
</html>