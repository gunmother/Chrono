<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Chrono</title>
<link rel="manifest" href="manifest.webmanifest">
<meta name="theme-color" content="#000000">
<style>
  :root{
    --bg:#e3eaf2; --ink:#42586d;
    --icon-inactive:#42586d; --icon-active:#4ff7ff;
    --pressed-navy:#355169; --turq-glow: rgba(79,247,255,.75);

    --off:5px; --blur:9px; --hi:#ffffff; --lo:#b7c3d1;
    --gap:24px; --radius:12px;

    --border:#c6cfda; --grid-line:#cfd9e5;
    --chart-bg:#d1dce8; --mask-surface: var(--bg);

    --hour-col:64px; --dow-h:32px; --label-size:12px;

    --marquee-border:5px;
    --marquee-shadow:0 0 12px 6px var(--turq-glow);

    /* handles & stamps */
    --handle-stroke:#5e7286;
    --chev-stroke-w:2.2;
    --handle-gap:10px;          /* stamp ↔ handle gap (both ends) */
    --top-handle-extra:10px;     /* mirror bottom spacing */
    --handle-height-mult:1.6;

    --stamp-gap:6px;             /* selection ↔ stamp gap */
    --stamp-h:26px;

    /* neumorphic pieces */
    --neu-shadow-outer:
      calc(-1*var(--off)) calc(-1*var(--off)) var(--blur) var(--hi),
       var(--off)         var(--off)         var(--blur) var(--lo);
    --neu-shadow-inner:
       inset calc(-1*var(--off)) calc(-1*var(--off)) var(--blur) var(--hi),
       inset var(--off)         var(--off)         var(--blur) var(--lo);
  }

  html,body{
    height:100%; margin:0; background:var(--bg); color:var(--ink);
    font:500 16px/1.4 system-ui,-apple-system,"Segoe UI",Roboto,Arial,sans-serif; overflow:hidden;
    -webkit-tap-highlight-color: transparent;
  }
  *{box-sizing:border-box}

  .app{
    width:clamp(320px, 96vw, 520px);
    height:calc(100svh - max(16px, env(safe-area-inset-top)) - max(16px, env(safe-area-inset-bottom)));
    margin:max(16px, env(safe-area-inset-top)) auto;
    display:flex; flex-direction:column; gap:var(--gap); padding:0 var(--gap);
  }

  #screen{
    flex:1; min-height:420px; border-radius:var(--radius); background:var(--bg);
    box-shadow: var(--neu-shadow-outer);
    position:relative; overflow:hidden;
  }

  /* Controls */
  .controls{ display:flex; gap:var(--gap); padding-bottom:2px; }
  .neu-btn{
    --btn-d: calc((100% - (3 * var(--gap))) / 4);
    flex:0 0 var(--btn-d); width:var(--btn-d); aspect-ratio:1/1;
    border-radius:50%; border:none; outline:none; cursor:pointer;
    background:var(--bg); display:grid; place-items:center;
    box-shadow: var(--neu-shadow-outer);
    transition: box-shadow .2s ease, background .2s ease, transform .06s ease;
  }
  .neu-btn svg{
    width:86%; height:auto; stroke:var(--icon-inactive); stroke-width:1.25;
    fill:none; stroke-linecap:round; stroke-linejoin:round;
    filter: drop-shadow(-0.6px -0.6px 0 var(--hi)) drop-shadow(0.6px 0.6px 0 var(--lo));
  }
  .neu-btn.is-pressed{
    background:
      radial-gradient(circle at 82% 82%, rgba(79,247,255,.12) 0%, rgba(79,247,255,.07) 34%, rgba(79,247,255,0) 60%),
      var(--pressed-navy);
    box-shadow:
       var(--off)         var(--off)         var(--blur) var(--hi),
      calc(-1*var(--off)) calc(-1*var(--off)) var(--blur) var(--lo);
  }
  .neu-btn.is-pressed svg{
    stroke:var(--icon-active);
    filter:drop-shadow(0 0 2px var(--turq-glow)) drop-shadow(0 0 10px var(--turq-glow));
  }
  .neu-btn:active{ transform:scale(.985); }
  .neu-btn:focus{ outline:none; }

  .neu-btn--sm{
    width:44px; height:44px; border-radius:12px; flex:0 0 auto;
    display:grid; place-items:center; background:var(--bg); border:none; cursor:pointer;
    box-shadow: var(--neu-shadow-outer);
    transition: box-shadow .2s ease, background .2s ease, transform .06s ease;
    -webkit-tap-highlight-color: transparent;
  }
  .neu-btn--sm svg{
    width:22px; height:22px; stroke:var(--icon-inactive); stroke-width:1.25; fill:none; stroke-linecap:round; stroke-linejoin:round;
    filter: drop-shadow(-0.6px -0.6px 0 var(--hi)) drop-shadow(0.6px 0.6px 0 var(--lo));
  }
  .neu-btn--sm.is-pressed{
    background:
      radial-gradient(circle at 82% 82%, rgba(79,247,255,.12) 0%, rgba(79,247,255,.07) 34%, rgba(79,247,255,0) 60%),
      var(--pressed-navy);
  }
  .neu-btn--sm.is-pressed svg{ stroke:var(--icon-active); filter:drop-shadow(0 0 2px var(--turq-glow)) drop-shadow(0 0 10px var(--turq-glow)); }
  .neu-btn--sm:active{ transform:scale(.985); }

  .wrap{ position:absolute; inset:0; display:grid; grid-template-rows:auto 1fr; min-width:0 }
  .head{ display:grid; grid-template-columns:auto 1fr auto; align-items:center; gap:8px; padding:8px 10px; }
  .title{ text-align:center; font-weight:800; font-size:16px; min-width:0; overflow:hidden; text-overflow:ellipsis; white-space:nowrap }

  .grid-area{ position:relative; overflow:hidden }
  .hours{ position:absolute; top:var(--dow-h); bottom:0; left:0; width:var(--hour-col); pointer-events:none; z-index:0 }
  .hour-stamp{ position:absolute; right:8px; transform:translateY(-50%); font-size:var(--label-size); color:var(--ink); opacity:.95; white-space:nowrap; text-align:right; }

  .top-row{ position:absolute; top:0; left:var(--hour-col); right:0; height:var(--dow-h); display:grid; align-items:center; min-width:0 }
  .top-row.week{ grid-template-columns:repeat(7,1fr); column-gap:8px; padding:0 6px }
  .day-pill{ justify-self:center; border:none; padding:0 2px; text-align:center; font-size:clamp(11px, 2vw, 13px); background:transparent; color:var(--ink) }

  .grid{
    position:absolute; top:var(--dow-h); left:var(--hour-col); right:0; bottom:0;
    background:var(--chart-bg);
    border-left:1px solid var(--grid-line); border-right:1px solid var(--grid-line);
    z-index:0;
  }
  .mask{ position:absolute; inset:0; pointer-events:none; shape-rendering:crispEdges; z-index:1 }

  /* Present lens — full hour block (compensates for border thickness) */
  .now{
    position:absolute;
    border:var(--marquee-border) solid #fff;
    border-radius:12px;
    box-shadow: var(--marquee-shadow);
    background:transparent;
    pointer-events:none;
    z-index:1;
    display:none;
  }

  /* Selection & stored blocks */
  .selHost{ position:absolute; inset:0; overflow:visible; pointer-events:none; z-index:2; }
  .marqueeRect{
    position:absolute; box-sizing:border-box; background:transparent;
    border:var(--marquee-border) solid #fff; border-radius:12px;
    pointer-events:none; box-shadow: var(--marquee-shadow);
  }
  .blockRect{
    position:absolute; box-sizing:border-box; border-radius:10px;
    pointer-events:none;
    box-shadow: var(--neu-shadow-outer);
    border:1px solid rgba(53,81,105,.25);
  }

  .overlayRoot{ position:fixed; inset:0; z-index:3; pointer-events:none; }
  .ov-group{ position:absolute; pointer-events:none; }

  .stamp{
    position:absolute; left:50%; transform:translateX(-50%);
    background:var(--pressed-navy); color:var(--icon-active);
    border:1px solid #273b4d; border-radius:10px; padding:4px 8px;
    font-size:12px; font-variant-numeric:tabular-nums; font-weight:900; letter-spacing:.02em; white-space:nowrap;
    pointer-events:none; z-index:5;
    box-shadow: 0 0 2px rgba(79,247,255,.35), 0 0 10px rgba(79,247,255,.35);
    height:var(--stamp-h); display:grid; place-items:center;
  }

  /* Chevron handles */
  .handle{ position:absolute; left:0; width:100%; pointer-events:auto; cursor:ns-resize; z-index:3; touch-action:none; display:grid; place-items:center; }
  .chev-chip{
    width:100%; height:100%; border-radius:14px;
    background:var(--bg);
    box-shadow: var(--neu-shadow-outer);
    display:grid; place-items:center;
  }
  .chev path{
    fill:none; stroke:var(--handle-stroke); stroke-width:var(--chev-stroke-w); stroke-linecap:round; stroke-linejoin:round;
    filter: drop-shadow(-0.6px -0.6px 0 var(--hi)) drop-shadow(0.6px 0.6px 0 var(--lo));
  }

  /* Side buttons (Settings / X) */
  .selBtns{ position:fixed; z-index:4; display:grid; gap:8px; pointer-events:auto; }
  .selBtns > button{ touch-action:manipulation; }
  .selBtnHidden{ display:none !important; }

  /* Month view */
  .month-wrap{ position:absolute; inset:0; display:grid; grid-template-rows:auto auto 1fr; }
  .month-dow{ display:grid; grid-template-columns:repeat(7,1fr); padding:6px 10px 0 10px; gap:6px; font-size:12px; letter-spacing:0.05em; color:var(--ink) }
  .month-dow span{ text-align:center }
  .month-grid{ height:100%; display:grid; grid-template-columns:repeat(7,1fr); grid-auto-rows:1fr; gap:8px; padding:10px; }
  .mcell{ position:relative; background:var(--bg); color:var(--ink); border-radius:8px; box-shadow:-1px -1px 0 0 var(--hi), 1px 1px 0 0 var(--lo); }
  .mcell .date{ position:absolute; top:8px; right:8px; font-weight:800; z-index:2; line-height:1; }
  .mcell.muted{ color:#8da0b3 }
  .mcell.today{
    box-shadow: var(--neu-shadow-outer);
  }
  .mcell.today::before{
    content:""; position:absolute; top:6px; right:6px; width:24px; height:24px; border-radius:50%;
    background:var(--pressed-navy);
    box-shadow: 0 0 2px rgba(79,247,255,.35), 0 0 10px rgba(79,247,255,.35);
  }
  .mcell.today .date{
    top:6px; right:6px; width:24px; height:24px; display:grid; place-items:center; color:var(--icon-active);
  }

  /* ===== Neumorphic Settings Modal ===== */
  .veil{ position:fixed; inset:0; background:rgba(0,0,0,.25); z-index:10; }
  .modal{
    position:fixed; left:50%; top:50%; transform:translate(-50%,-50%);
    width:min(92vw, 360px); background:var(--bg); color:var(--ink);
    border-radius:12px; box-shadow: var(--neu-shadow-outer); z-index:11;
    display:grid; grid-template-rows:auto 1fr auto; max-height:88vh; overflow:hidden;
  }
  .modal .head{
    padding:12px 14px; font-weight:800;
    background:var(--bg); box-shadow: var(--neu-shadow-inner);
    display:flex; align-items:center; justify-content:center;
  }
  .modal .foot{
    padding:10px 14px; display:flex; justify-content:flex-end; gap:10px;
    background:var(--bg); box-shadow: var(--neu-shadow-inner);
  }
  .btn{ border:none; background:var(--bg); border-radius:10px; padding:10px 14px; font-weight:800; cursor:pointer; box-shadow: var(--neu-shadow-outer); }
  .btn:active{ transform:scale(.985); }
  .btn.ok{ background:var(--bg); }
  .btn.icon{ width:40px; height:40px; display:grid; place-items:center; }
  .btn.icon svg{
    width:18px; height:18px; stroke:var(--icon-inactive); fill:none; stroke-width:1.5;
    filter: drop-shadow(-0.6px -0.6px 0 var(--hi)) drop-shadow(0.6px 0.6px 0 var(--lo));
  }

  .settings-wrap{ padding:14px; display:grid; gap:14px; overflow:auto; }

  .neu-field{ background:var(--bg); border-radius:12px; padding:10px; box-shadow: var(--neu-shadow-inner); display:grid; gap:8px; }
  .label{ font-weight:800; font-size:13px; color:#223; }

  .neu-select{
    display:flex; align-items:center; justify-content:space-between; gap:10px;
    padding:10px 12px; border-radius:12px; background:var(--bg); box-shadow: var(--neu-shadow-outer); cursor:pointer;
    user-select:none;
  }
  .neu-select .ph{ opacity:.7; }
  .neu-select svg{ width:18px; height:18px; stroke:var(--icon-inactive); fill:none; stroke-width:1.5;
    filter: drop-shadow(-0.6px -0.6px 0 var(--hi)) drop-shadow(0.6px 0.6px 0 var(--lo));
  }
  .neu-menu{ display:none; position:relative; }
  .neu-menu.open{ display:block; }
  .menu-card{ margin-top:8px; background:var(--bg); border-radius:12px; box-shadow: var(--neu-shadow-outer); overflow:hidden; }
  .menu-item{ padding:10px 12px; cursor:pointer; display:flex; align-items:center; gap:10px; }
  .menu-item:not(:last-child){ border-bottom:1px solid var(--grid-line); }
  .menu-dot{ width:12px; height:12px; border-radius:50%; box-shadow: var(--neu-shadow-inner); }

  .chip{
    display:flex; align-items:center; gap:8px; border-radius:999px; padding:6px 10px;
    background:var(--bg); box-shadow: var(--neu-shadow-outer); font-weight:800; width:fit-content;
  }
  .dot{ width:12px; height:12px; border-radius:50%; border:1px solid #273b4d; box-shadow: var(--neu-shadow-inner); }
  .chip .edit{ border:none; background:transparent; display:grid; place-items:center; cursor:pointer; }
  .chip .edit svg{ width:16px; height:16px; stroke:var(--icon-inactive); fill:none; stroke-width:1.6;
    filter: drop-shadow(-0.6px -0.6px 0 var(--hi)) drop-shadow(0.6px 0.6px 0 var(--lo));
  }

  .note-field{ display:grid; gap:6px; }
  .note-input{
    background:var(--bg); border:none; outline:none; border-radius:12px; padding:10px 12px; font-weight:700;
    box-shadow: var(--neu-shadow-inner);
  }

  .row4{ display:grid; grid-template-columns:1fr 1fr; gap:10px; }
  .row{ display:flex; align-items:center; gap:10px; flex-wrap:wrap; }

  .time-row{ display:grid; gap:8px; }
  .time-pair{
    display:flex; align-items:center; justify-content:space-between; gap:10px;
    padding:10px 12px; border-radius:12px; background:var(--bg); box-shadow: var(--neu-shadow-outer);
  }
  .time-btn{ border:none; background:transparent; font-weight:800; cursor:pointer; user-select:none; }
  .time-day{ font-weight:900; letter-spacing:.02em; opacity:.85; }

  .swatch-grid{ display:grid; grid-template-columns:repeat(6, 1fr); gap:8px; }
  .sw{ width:32px; height:32px; border-radius:10px; box-shadow: var(--neu-shadow-outer); cursor:pointer; border:1px solid rgba(0,0,0,.08); }
  .sw.sel{ box-shadow: 0 0 0 2px #fff, 0 0 0 4px var(--pressed-navy), var(--neu-shadow-outer); }

  /* Stats */
  .stat-line{ display:flex; justify-content:space-between; font-weight:800; padding:8px 0; border-bottom:1px solid #d8e1ec; }
  .pct{ font-weight:900; }
  .pct.green{ color:#15a05c; }
  .pct.yellow{ color:#b18a00; }
  .pct.orange{ color:#c85b00; }
  .pct.red{ color:#bf1b1b; }
</style>
</head>
<body>
  <main class="app">
    <section id="screen" aria-live="polite" aria-label="Content area"></section>

    <nav class="controls" role="group" aria-label="Primary views">
      <!-- Day -->
      <button class="neu-btn" aria-label="Day view" aria-pressed="false" data-view="day" title="Day">
        <svg viewBox="0 0 24 24" aria-hidden="true">
          <circle cx="12" cy="12" r="5.5"/>
          <line x1="12" y1="2"  x2="12" y2="5"/>
          <line x1="12" y1="19" x2="12" y2="22"/>
          <line x1="2"  y1="12" x2="5"  y2="12"/>
          <line x1="19" y1="12" x2="22" y2="12"/>
          <line x1="17" y1="7"  x2="19" y2="5"/>
          <line x1="7"  y1="17" x2="5"  y2="19"/>
          <line x1="7"  y1="7"  x2="5"  y2="5"/>
          <line x1="17" y1="17" x2="19" y2="19"/>
        </svg>
      </button>

      <!-- Week -->
      <button class="neu-btn" aria-label="Week view" aria-pressed="false" data-view="week" title="Week">
        <svg viewBox="0 0 24 24" aria-hidden="true">
          <rect x="3" y="4.5" width="18" height="15" rx="3"/>
          <line x1="3" y1="8" x2="21" y2="8"/>
          <line x1="6" y1="10" x2="6" y2="18.5"/>
          <line x1="9" y1="10" x2="9" y2="18.5"/>
          <line x1="12" y1="10" x2="12" y2="18.5"/>
          <line x1="15" y1="10" x2="15" y2="18.5"/>
          <line x1="18" y1="10" x2="18" y2="18.5"/>
        </svg>
      </button>

      <!-- Month -->
      <button class="neu-btn" aria-label="Month view" aria-pressed="false" data-view="month" title="Month">
        <svg viewBox="0 0 24 24" aria-hidden="true">
          <rect x="3" y="4.5" width="18" height="15" rx="3"/>
          <line x1="3" y1="8" x2="21" y2="8"/>
          <g>
            <circle cx="7" cy="11" r="0.8"/><circle cx="11" cy="11" r="0.8"/><circle cx="15" cy="11" r="0.8"/>
            <circle cx="7" cy="14" r="0.8"/><circle cx="11" cy="14" r="0.8"/><circle cx="15" cy="14" r="0.8"/>
            <circle cx="7" cy="17" r="0.8"/><circle cx="11" cy="17" r="0.8"/><circle cx="15" cy="17" r="0.8"/>
          </g>
        </svg>
      </button>

      <!-- To-Do -->
      <button class="neu-btn" aria-label="To-Do list" aria-pressed="false" data-view="todo" title="To-Do">
        <svg viewBox="0 0 24 24" aria-hidden="true">
          <rect x="4" y="5" width="16" height="14" rx="3"/>
          <line x1="4" y1="8" x2="20" y2="8"/>
          <polyline points="7,14 10,17 17,10"/>
        </svg>
      </button>
    </nav>
  </main>

<script>
console.info('Chrono r70 — neumorphic settings UI, activity ordering, defaults, notes, AM/PM picker, save leaves colored block.');

const screenEl = document.getElementById('screen');
const buttons = [...document.querySelectorAll('.neu-btn')];

let activeView = null; // screensaver by default
let activeDayISO = toISO(new Date());
let visibleWeekFirst = weekStart(new Date());

const SHORT_DOW=['Sun','Mon','Tue','Wed','Thu','Fri','Sat'];
const MONTH_INIT=['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];

function toISO(d){ return `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')}`; }
function addDays(d,n){ const x=new Date(d); x.setDate(x.getDate()+n); return x; }
function weekStart(d){ const x=new Date(d.getFullYear(), d.getMonth(), d.getDate()); const dow=x.getDay(); x.setDate(x.getDate()-dow); x.setHours(0,0,0,0); return x; }
function startOfDay(d){ const x=new Date(d); x.setHours(0,0,0,0); return x; }
function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }
function snap15(n){ return 15 * Math.round((+n||0)/15); }
function totalDur(a){ return (a.endMin - a.startMin); }
function hourToAMPM(h){ return h===0? '12 AM' : h<12? `${h} AM` : h===12? '12 PM' : `${h-12} PM`; }
function HHMM(min){ const m=((Math.round(min)|0)+1440)%1440; const h=Math.floor(m/60), r=m%60; return `${String(h).padStart(2,'0')}:${String(r).padStart(2,'0')}`; }
function HHMM_ampm(min){
  const m=((Math.round(min)|0)+1440)%1440; let h=Math.floor(m/60), r=m%60;
  const am = h<12; h = (h%12)||12; return `${String(h).padStart(2,'0')}:${String(r).padStart(2,'0')} ${am?'AM':'PM'}`;
}
function ampmToMin(str){
  const m = str.match(/^(\d{1,2}):(\d{2})\s*(AM|PM)$/i); if(!m) return null;
  let h=+m[1], mm=+m[2], ap=m[3].toUpperCase(); if(h<1||h>12||mm%15!==0) return null;
  if(h===12) h=0; if(ap==='PM') h+=12; return h*60+mm;
}

const DAY_MS = 86400000;
function weekStamp(d){ return +weekStart(d); }
function stampToDate(st){ return new Date(st); }
function getVisibleWeekStamp(){ return weekStamp(visibleWeekFirst); }

new ResizeObserver(()=> {
  const w = screenEl.getBoundingClientRect().width;
  document.documentElement.style.setProperty('--panelW', Math.max(320, Math.floor(w))+'px');
}).observe(screenEl);

/* storage */
const DB_NAME='chronoDB', DB_VERSION=26;
let dbPromise=null, STORAGE_MODE='idb';
function idbSupported(){ try { return !!window.indexedDB; } catch { return false; } }
function idbOpen(){
  if(!idbSupported()){ STORAGE_MODE='ls'; return Promise.resolve(null); }
  if(dbPromise) return dbPromise;
  dbPromise = new Promise((resolve,reject)=>{
    const req = indexedDB.open(DB_NAME, DB_VERSION);
    req.onupgradeneeded = ()=>{
      const db = req.result;
      if(!db.objectStoreNames.contains('kv')) db.createObjectStore('kv',{keyPath:'k'});
      if(!db.objectStoreNames.contains('blocks')) db.createObjectStore('blocks',{keyPath:'id'});
    };
    req.onsuccess = ()=>resolve(req.result);
    req.onerror   = ()=>reject(req.error);
  });
  return dbPromise.catch(()=>{ STORAGE_MODE='ls'; return null; });
}
async function storageSet(k,v){
  if(STORAGE_MODE==='ls'){ if(v===undefined) localStorage.removeItem(k); else localStorage.setItem(k, JSON.stringify(v)); return true; }
  const db = await idbOpen(); if(!db){ STORAGE_MODE='ls'; return storageSet(k,v); }
  return new Promise((res,rej)=>{
    const tx=db.transaction('kv','readwrite');
    const store=tx.objectStore('kv');
    if(v===undefined) store.delete(k); else store.put({k,v});
    tx.oncomplete=()=>res(true); tx.onerror = ()=>rej(tx.error);
  });
}
async function storageGet(k){
  if(STORAGE_MODE==='ls'){ const s=localStorage.getItem(k); return s? JSON.parse(s):undefined; }
  const db = await idbOpen(); if(!db){ STORAGE_MODE='ls'; return storageGet(k); }
  return new Promise((res,rej)=>{
    const tx=db.transaction('kv','readonly');
    const req=tx.objectStore('kv').get(k);
    req.onsuccess=()=>res(req.result? req.result.v:undefined);
    req.onerror=()=>rej(req.error);
  });
}

/* blocks store */
async function putBlock(b){
  const db = await idbOpen(); if(!db) return;
  return new Promise((res,rej)=>{
    const tx=db.transaction('blocks','readwrite');
    tx.objectStore('blocks').put(b);
    tx.oncomplete=()=>res(true);
    tx.onerror=()=>rej(tx.error);
  });
}
async function getBlocksAll(){
  const db = await idbOpen(); if(!db) return [];
  return new Promise((res,rej)=>{
    const tx=db.transaction('blocks','readonly');
    const store=tx.objectStore('blocks');
    const req=store.getAll();
    req.onsuccess=()=>res(req.result||[]);
    req.onerror=()=>rej(req.error);
  });
}

/* ===== Activities & Colors ===== */

/* Ordered list per spec */
const ACTIVITY_LIST = [
  {key:'work', label:'Work'},
  {key:'school', label:'School'},
  {key:'commute', label:'Commute'},
  {key:'chores', label:'Chores'},
  {key:'errands', label:'Errands'},
  {key:'meal', label:'Meal Time'},
  {key:'hygiene', label:'Hygiene'},
  {key:'childcare', label:'Child Care'},
  {key:'selfcare', label:'Self Care'},
  {key:'exercise', label:'Exercise'},
  {key:'family', label:'Family Time'},
  {key:'hobbies', label:'Hobbies'},
  {key:'projects', label:'Projects'},
  {key:'rr', label:'R & R'},
  {key:'free', label:'Free Time'},
  {key:'sleep', label:'Sleep'}
];

/* Preassigned default colors (placeholder tones).
   ⚠️ Replace with your exact 18-swatch shades when you provide the hex values. */
const COLOR_SWATCHES = [
  '#E5484D','#3E63DD','#22C55E','#EAB308','#F97316','#0EA5E9',
  '#8B5CF6','#10B981','#EF4444','#7DD3FC','#94A3B8','#F59E0B',
  '#14B8A6','#F43F5E','#A3E635','#111827','#6EE7B7','#FCA5A5'
];

/* Activity → default swatch index (you can remap after providing exact colors) */
const ACTIVITY_COLOR = {
  work:0, school:1, commute:3, chores:10, errands:9, meal:4, hygiene:5, childcare:15,
  selfcare:6, exercise:2, family:16, hobbies:6, projects:12, rr:13, free:14, sleep:1
};

/* Defaults: Firm for Work, Commute, School, Child Care; Flexible for others */
function defaultFlexForActivity(key){
  return (key==='work'||key==='commute'||key==='school'||key==='childcare') ? 'firm' : 'flexible';
}

function getActivityByKey(k){ return ACTIVITY_LIST.find(a=>a.key===k) || ACTIVITY_LIST[0]; }
function colorForActivity(k){
  const idx = ACTIVITY_COLOR[k]; const hex = COLOR_SWATCHES[idx ?? 0];
  return hex || COLOR_SWATCHES[0];
}

/* selection (in-progress) */
const CHAIN_KEY='selChain_v12';
async function saveChain(c){ await storageSet(CHAIN_KEY, c||undefined); }
async function loadChain(){ return (await storageGet(CHAIN_KEY)) || null; }

let chain = null;
let dragKind=null, dragTarget='parent';
let dragStartY=0, baseStart=0, baseEnd=0;
let baseOtherStart=0, baseOtherEnd=0, otherDurAtStart=0;
let dragPixels=0, wasDrag=false;
let crossedTop=false, crossedBottom=false, lastEdgeCrossed=null;

document.querySelector('.controls').addEventListener('click', e=>{
  const b=e.target.closest('.neu-btn'); if(!b) return;
  const v=b.dataset.view;

  const wasPressed = b.classList.contains('is-pressed');
  buttons.forEach(x=>{ x.classList.remove('is-pressed'); x.setAttribute('aria-pressed','false'); });
  if(!wasPressed){ b.classList.add('is-pressed'); b.setAttribute('aria-pressed','true'); }

  if(activeView===v){
    activeView=null; buttons.forEach(x=>x.setAttribute('aria-pressed','false')); screenEl.innerHTML='';
    destroySelButtons(); destroyOverlay();
  }else{
    activeView=v; render();
  }
  saveSoon(200);
});

/* week view */
let weekGeom=null;
let overlayRoot=null;
let _modalOpen=false;  // single modal guard

function buildWeekView(){
  screenEl.innerHTML = `
    <div class="wrap">
      <div class="head">
        <button id="prevWeekBtn" class="neu-btn--sm" aria-label="Previous week" title="Previous">
          <svg viewBox="0 0 24 24" aria-hidden="true"><polyline points="15,5 8,12 15,19"/></svg>
        </button>
        <div class="title" id="weekTitle"></div>
        <button id="nextWeekBtn" class="neu-btn--sm" aria-label="Next week" title="Next">
          <svg viewBox="0 0 24 24" aria-hidden="true"><polyline points="9,5 16,12 9,19"/></svg>
        </button>
      </div>

      <div class="grid-area">
        <div class="top-row week" id="dowPills"></div>
        <div class="grid" id="weekGrid" aria-label="Weekly grid" role="grid">
          <svg class="mask" id="maskSVG" aria-hidden="true"></svg>
          <div class="now" id="nowMagnify" aria-hidden="true"></div>
          <div class="selHost" id="selHost" aria-hidden="false"></div>
          <div class="selHost" id="blocksHost" aria-hidden="true"></div>
        </div>
        <div class="hours" id="weekHours"></div>
      </div>
    </div>
  `;

  const prev = document.getElementById('prevWeekBtn');
  const next = document.getElementById('nextWeekBtn');
  prev.onclick = async ()=>{
    pressFlash(prev); visibleWeekFirst=addDays(visibleWeekFirst,-7);
    repaintWeek(); await loadAndDraw(); saveSoon(200); unpressFlash(prev);
  };
  next.onclick = async ()=>{
    pressFlash(next); visibleWeekFirst=addDays(visibleWeekFirst, 7);
    repaintWeek(); await loadAndDraw(); saveSoon(200); unpressFlash(next);
  };

  const grid=document.getElementById('weekGrid');
  grid.addEventListener('click', onWeekGridTap, {passive:true});

  ensureOverlay();

  repaintWeek();
  new ResizeObserver(()=>{ repaintWeek(true); drawSelection(); drawBlocks(); }).observe(grid);

  const syncViewport = throttle(()=>{ if(activeView==='week'){ repaintWeek(true); drawSelection(); repositionSelButtons(); } }, 32);
  window.addEventListener('scroll', syncViewport, {passive:true});
  window.addEventListener('orientationchange', syncViewport, {passive:true});
  if (window.visualViewport) window.visualViewport.addEventListener('resize', syncViewport, {passive:true});

  loadAndDraw().catch(()=>{});
}

/* quick flash */
function pressFlash(btn){
  btn.classList.add('is-pressed');
  btn.querySelector('svg').style.filter = 'drop-shadow(0 0 2px var(--turq-glow)) drop-shadow(0 0 10px var(--turq-glow))';
}
function unpressFlash(btn){ setTimeout(()=>{ btn.classList.remove('is-pressed'); btn.querySelector('svg').style.filter='drop-shadow(-0.6px -0.6px 0 var(--hi)) drop-shadow(0.6px 0.6px 0 var(--lo))'; }, 160); }

function ensureOverlay(){
  if(overlayRoot && document.body.contains(overlayRoot)) return;
  overlayRoot=document.createElement('div'); overlayRoot.className='overlayRoot'; overlayRoot.id='overlayRoot';
  document.body.appendChild(overlayRoot);
}
function destroyOverlay(){ overlayRoot?.remove(); overlayRoot=null; }

async function loadAndDraw(){ chain = await loadChain(); sanitizeChain(); drawSelection(); drawBlocks(); }

function repaintWeek(skipSel=false){
  const first=visibleWeekFirst, last=addDays(first,6);
  document.getElementById('weekTitle').textContent =
    `${MONTH_INIT[first.getMonth()]} ${first.getDate()} – ${MONTH_INIT[last.getMonth()]} ${last.getDate()}`;

  const pills=document.getElementById('dowPills'); pills.innerHTML='';
  for(let i=0;i<7;i++){ const el=document.createElement('div'); el.className='day-pill'; el.textContent = SHORT_DOW[i]; pills.appendChild(el); }

  const gh=document.getElementById('weekHours'); gh.innerHTML='';
  const gridEl=document.getElementById('weekGrid');
  weekGeom=computeGeometry(gridEl,7);
  for(let i=0;i<24;i++){
    const s=document.createElement('div'); s.className='hour-stamp';
    s.textContent = hourToAMPM(i);
    s.style.top=((weekGeom.rowY[i]+weekGeom.rowY[i+1])/2)+'px';
    gh.appendChild(s);
  }

  buildMask(weekGeom,7);
  paintNowMagnifier(weekGeom);

  if(chain && !skipSel) drawSelection();
}

function computeGeometry(gridEl, cols){
  const r=gridEl.getBoundingClientRect();
  const totalW=Math.max(0, Math.round(r.width));
  const totalH=Math.max(0, Math.round(r.height));
  const colWBase=Math.floor(totalW/cols), extraW=totalW-colWBase*cols;
  const rowHBase=Math.floor(totalH/24), extraH=totalH-rowHBase*24;

  const colW=[], colX=[0]; for(let c=0;c<cols;c++){ const w=colWBase+(c<extraW?1:0); colW.push(w); colX.push(colX[c]+w); }
  const rowH=[], rowY=[0]; for(let i=0;i<24;i++){ const h=rowHBase+(i<extraH?1:0); rowH.push(h); rowY.push(rowY[i]+h); }

  const slotY=[0];
  for(let hr=0;hr<24;hr++){
    const h=rowH[hr];
    const base=Math.floor(h/4); let rem=h-base*4;
    const parts=[base,base,base,base]; for(let k=0;k<rem;k++) parts[k]+=1;
    for(let q=0;q<4;q++) slotY.push(slotY[slotY.length-1]+parts[q]);
  }
  return {totalW,totalH,colW,colX,rowH,rowY,slotY, rect:r};
}

function buildMask(geom, cols){
  const svg=document.getElementById('maskSVG'); svg.innerHTML='';
  const { totalW, totalH, colX, rowY } = geom;
  if(totalW<=0 || totalH<=0) return;
  svg.setAttribute('width', totalW);
  svg.setAttribute('height', totalH);
  svg.setAttribute('viewBox', `0 0 ${totalW} ${totalH}`);
  svg.setAttribute('preserveAspectRatio','none');

  const NS='http://www.w3.org/2000/svg';
  const defs=document.createElementNS(NS,'defs');
  const sym=document.createElementNS(NS,'symbol');
  sym.setAttribute('id','tile900x300');
  sym.setAttribute('viewBox','0 0 900 300');
  sym.setAttribute('preserveAspectRatio','none');

  const surface=getComputedStyle(document.documentElement).getPropertyValue('--mask-surface')||'#e3eaf2';
  const rct=(x,y,w,h)=>{const e=document.createElementNS(NS,'rect'); e.setAttribute('x',x); e.setAttribute('y',y); e.setAttribute('width',w); e.setAttribute('height',h); e.setAttribute('fill',surface); return e;};
  const poly=(pts)=>{const e=document.createElementNS(NS,'polygon'); e.setAttribute('points',pts); e.setAttribute('fill',surface); return e;};

  sym.appendChild(rct(0,0,900,24)); sym.appendChild(rct(0,276,900,24));
  sym.appendChild(rct(0,0,24,300)); sym.appendChild(rct(876,0,24,300));
  sym.appendChild(rct(24,69,852,24)); sym.appendChild(rct(24,138,852,24)); sym.appendChild(rct(24,207,852,24));
  sym.appendChild(poly('23,23 61,23 23,61')); sym.appendChild(poly('877,23 839,23 877,61')); sym.appendChild(poly('23,277 61,277 23,239')); sym.appendChild(poly('877,277 839,277 877,239'));

  defs.appendChild(sym); svg.appendChild(defs);

  for(let rI=0;rI<24;rI++){
    for(let cI=0;cI<cols;cI++){
      const use=document.createElementNS(NS,'use');
      use.setAttribute('href','#tile900x300');
      use.setAttribute('x',colX[cI]); use.setAttribute('y',rowY[rI]);
      use.setAttribute('width',colX[cI+1]-colX[cI]);
      use.setAttribute('height',rowY[rI+1]-rowY[rI]);
      svg.appendChild(use);
    }
  }
}

/* Present lens (full hour block, border compensated) */
function paintNowMagnifier(geom){
  const nowEl=document.getElementById('nowMagnify');
  const today=new Date(); const visStart=visibleWeekFirst; const visEnd=addDays(visStart,6);
  if(+startOfDay(today) < +startOfDay(visStart) || +startOfDay(today) > +startOfDay(visEnd)){ nowEl.style.display='none'; return; }
  const {colX,rowY} = geom;
  const dow=today.getDay();
  const hour=today.getHours();

  const border = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--marquee-border'))||5;

  const hourTop=rowY[hour];
  const hourH=rowY[hour+1]-rowY[hour];
  const left=colX[dow];
  const width=(colX[dow+1]-colX[dow] - (dow===6?1:0));

  nowEl.style.left=(left - border/2)+'px';
  nowEl.style.top=(hourTop - border/2)+'px';
  nowEl.style.width=(width + border)+'px';
  nowEl.style.height=(hourH + border)+'px';
  nowEl.style.display='block';
}

/* create on tap — prompt if new selection touches edges */
async function onWeekGridTap(e){
  if(!weekGeom) return;
  destroySelButtons();
  const rect=weekGeom.rect;
  const relX=e.clientX - rect.left;
  const relY=e.clientY - rect.top;

  let dayIdx=0;
  for(let i=0;i<7;i++){ if(relX >= weekGeom.colX[i] && relX < weekGeom.colX[i+1]){ dayIdx=i; break; } }

  const minuteFloat = clamp(relY / weekGeom.totalH, 0, 1) * 1440;
  let startMin = snap15(Math.floor(minuteFloat/60)*60);
  let endMin   = clamp(startMin + 60, 0, 1440);

  chain = { id: Date.now(), parent: { weekSt:getVisibleWeekStamp(), dayIdx, startMin, endMin }, child: null, dir: null };
  await saveChain(chain); drawSelection();

  if(!_modalOpen){
    if(chain.parent.startMin===0){ await spilloverConfirm('prev'); }
    else if(chain.parent.endMin===1440){ await spilloverConfirm('next'); }
  }
}

/* helpers */
function minutesToY(min){ const idx = clamp(Math.round(min/15), 0, 96); return weekGeom.slotY[idx]; }
function segOnThisWeek(seg){ return seg && seg.weekSt === getVisibleWeekStamp(); }
function boundsFromSeg(seg){
  const colLeft = weekGeom.colX[seg.dayIdx];
  const colRight= weekGeom.colX[seg.dayIdx+1];
  const colWidth= (colRight - colLeft) - (seg.dayIdx===6?1:0);
  const topY  = minutesToY(seg.startMin);
  const botY  = minutesToY(seg.endMin);
  const height= Math.max(1, botY - topY);
  return {offsetLeft:colLeft, offsetTop:0, colWidth, topY, botY, height};
}

/* chevrons (identical, just flipped) */
function chevronsSVG(dir, colW, rowH){
  const padX = 8;
  const w = Math.max(24, colW - padX*2);
  const h = Math.max(44, Math.floor(rowH*parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--handle-height-mult'))||1.6));
  const mid = w/2;
  const gap = h/6;
  const span = Math.min(w*0.42, h/4);

  const triUp = (y)=>`M ${mid-span} ${y+span} L ${mid} ${y} L ${mid+span} ${y+span}`;
  const triDn = (y)=>`M ${mid-span} ${y} L ${mid} ${y+span} L ${mid+span} ${y}`;

  const d1 = (dir==='up'? triUp(gap) : triDn(gap));
  const d2 = (dir==='up'? triUp(gap*2.2) : triDn(gap*2.2));
  const d3 = (dir==='up'? triUp(gap*3.4) : triDn(gap*3.4));

  return `<div class="chev">
    <svg width="${w}" height="${h}" viewBox="0 0 ${w} ${h}" aria-hidden="true">
      <path d="${d1}"/><path d="${d2}"/><path d="${d3}"/>
    </svg>
  </div>`;
}

/* draw stored blocks (current week + simple recurrences) */
async function drawBlocks(){
  const host=document.getElementById('blocksHost'); if(!host || !weekGeom) return;
  host.innerHTML='';

  const blocks = await getBlocksAll();
  const wst = getVisibleWeekStamp();

  const instances = [];
  for(const b of blocks){
    if(b.recurrence==='none'){
      if(b.weekSt===wst) instances.push(b);
    }else if(b.recurrence==='weekly'){
      if(wst>=b.weekSt){
        const weeksDiff = Math.floor((wst - b.weekSt)/DAY_MS/7);
        if(weeksDiff>=0) instances.push({...b, weekSt:wst});
      }
    }else if(b.recurrence==='monthly'){
      if(b.weekSt===wst) instances.push(b); // (placeholder monthly)
    }
  }

  for(const seg of instances){
    const b=boundsFromSeg(seg);
    const el=document.createElement('div');
    el.className='blockRect';
    el.style.left = `${b.offsetLeft+2}px`;
    el.style.top = `${b.topY+2}px`;
    el.style.width = `${b.colWidth-4}px`;
    el.style.height = `${b.height-4}px`;
    const color = seg.colorHex || colorForActivity(seg.activityKey);
    el.style.background = hexWithAlpha(color, .22);
    el.style.borderColor = color;
    host.appendChild(el);
  }
}
function hexWithAlpha(hex, a){
  const h = hex.replace('#',''); const bigint=parseInt(h,16);
  const r=(bigint>>16)&255, g=(bigint>>8)&255, b=(bigint)&255;
  return `rgba(${r},${g},${b},${a})`;
}

/* draw selection + side cluster (that avoids handles) */
function drawSelection(){
  const host=document.getElementById('selHost'); if(!host) { destroySelButtons(); return; }
  if(!overlayRoot) ensureOverlay();
  host.innerHTML=''; overlayRoot.innerHTML='';

  if(!chain){ destroySelButtons(); return; }

  const parentHere = segOnThisWeek(chain.parent);
  const childHere  = segOnThisWeek(chain.child);

  if(!parentHere && !childHere){ destroySelButtons(); return; }

  const segs=[];
  if(parentHere) segs.push({seg:chain.parent, name:'parent'});
  if(childHere)  segs.push({seg:chain.child,  name:'child'});
  segs.sort((a,b)=> (a.seg.weekSt-b.seg.weekSt) || (a.seg.dayIdx-b.seg.dayIdx));

  const bothVisible = parentHere && childHere;

  const handleCenters=[]; // for avoidance

  segs.forEach((entry, idx)=>{
    const seg=entry.seg, name=entry.name;
    const b=boundsFromSeg(seg);

    const rectEl=document.createElement('div');
    rectEl.className='marqueeRect';
    rectEl.dataset.name=name;
    rectEl.style.left   = `${b.offsetLeft}px`;
    rectEl.style.top    = `${b.offsetTop + b.topY}px`;
    rectEl.style.width  = `${b.colWidth}px`;
    rectEl.style.height = `${b.height}px`;
    host.appendChild(rectEl);

    const group=document.createElement('div');
    group.className='ov-group';
    group.style.left = (weekGeom.rect.left + b.offsetLeft) + 'px';
    group.style.top  = (weekGeom.rect.top  + b.topY) + 'px';
    group.style.width= b.colWidth + 'px';
    group.style.height= b.height + 'px';
    overlayRoot.appendChild(group);

    let renderTop=false, renderBottom=false;
    if(!chain.child){ renderTop = renderBottom = true; }
    else if(bothVisible){ renderTop = (idx===0); renderBottom = (idx===segs.length-1); }
    else{
      if(chain.dir==='next'){ if(name==='parent') renderTop=true; else renderBottom=true; }
      if(chain.dir==='prev'){ if(name==='parent') renderBottom=true; else renderTop=true; }
    }

    const rowH = weekGeom.rowH[0] || 48;
    const hH = rowH * (parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--handle-height-mult'))||1.6);
    const hGap = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--handle-gap'))||10;
    const topExtra = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--top-handle-extra'))||0;
    const sGap = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--stamp-gap'))||6;
    const sH   = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--stamp-h'))||26;

    if(renderTop){
      const topStamp=document.createElement('div'); topStamp.className='stamp';
      topStamp.textContent = HHMM(seg.startMin);
      topStamp.style.left = (b.colWidth/2)+'px';
      topStamp.style.top  = (- (sGap + sH))+'px';
      group.appendChild(topStamp);

      const topHandle=document.createElement('div'); topHandle.className='handle top';
      topHandle.style.left='0px';
      topHandle.style.top = (- (sGap + sH + hGap + hH + topExtra))+'px';
      topHandle.style.width=b.colWidth+'px'; topHandle.style.height=hH+'px';
      topHandle.innerHTML = `<div class="chev-chip">${chevronsSVG('up', b.colWidth, rowH)}</div>`;
      topHandle.addEventListener('pointerdown', ev=>startDrag(ev,'top', name), {passive:false});
      group.appendChild(topHandle);

      handleCenters.push(weekGeom.rect.top + b.topY - (sGap + sH + hGap + (hH/2) + topExtra));
    }

    if(renderBottom){
      const botStamp=document.createElement('div'); botStamp.className='stamp';
      botStamp.textContent = HHMM(seg.endMin);
      botStamp.style.left = (b.colWidth/2)+'px';
      botStamp.style.top  = (b.height + sGap)+'px';
      group.appendChild(botStamp);

      const botHandle=document.createElement('div'); botHandle.className='handle bottom';
      botHandle.style.left='0px';
      botHandle.style.top = (b.height + sGap + sH + hGap)+'px';
      botHandle.style.width=b.colWidth+'px'; botHandle.style.height=hH+'px';
      botHandle.innerHTML = `<div class="chev-chip">${chevronsSVG('down', b.colWidth, rowH)}</div>`;
      botHandle.addEventListener('pointerdown', ev=>startDrag(ev,'bottom', name), {passive:false});
      group.appendChild(botHandle);

      handleCenters.push(weekGeom.rect.top + b.topY + b.height + sGap + sH + hGap + (hH/2));
    }
  });

  ensureSelButtons();

  // Position cluster using union bounds, then nudge to avoid handle overlap
  const visibleBounds = segs.map(s=>({name:s.name, b:boundsFromSeg(s.seg)}));
  const topMin = Math.min(...visibleBounds.map(v=>v.b.topY));
  const botMax = Math.max(...visibleBounds.map(v=>v.b.botY));
  const heightUnion = botMax - topMin;

  const vpCenter = (window.scrollY + window.innerHeight/2) - weekGeom.rect.top;
  let anchor = visibleBounds[0];
  let best = Math.abs(((anchor.b.topY+anchor.b.botY)/2) - vpCenter);
  for(const v of visibleBounds){
    const mid = (v.b.topY + v.b.botY)/2;
    const d = Math.abs(mid - vpCenter);
    if(d < best){ best=d; anchor=v; }
  }

  const rect = {
    left: weekGeom.rect.left + anchor.b.offsetLeft,
    right: weekGeom.rect.left + anchor.b.offsetLeft + anchor.b.colWidth,
    top: weekGeom.rect.top + topMin,
    height: heightUnion
  };

  function positionWithAvoidance(r){
    const margin=8, btnW=44, totalH=(44*2)+8;
    let left = r.right + margin;
    let top  = r.top + (r.height/2) - (totalH/2);

    if(left + btnW > window.innerWidth - margin){
      left = Math.max(margin, r.left - margin - btnW);
    }

    const clearance = 30;
    const spanTop = top, spanBot = top + totalH;
    for(const hc of handleCenters){
      if(spanTop - clearance < hc && hc < spanBot + clearance){
        if(hc >= (spanTop+spanBot)/2) top = Math.max(margin, hc - clearance - totalH);
        else top = Math.min(window.innerHeight - margin - totalH, hc + clearance);
      }
    }

    if(top + totalH > window.innerHeight - margin){
      top = Math.max(margin, window.innerHeight - margin - totalH);
    }
    if(top < margin) top = margin;

    positionSelButtons({left, top});
  }

  positionWithAvoidance(rect);
  attachViewportRepositioners();
}

/* Drag & spillover */
function otherSeg(which){ return which==='parent' ? chain.child : chain.parent; }
function dur(seg){ return seg? seg.endMin - seg.startMin : 0; }

function clampToBudget(seg, which){
  const minGap=15;
  const hasChild = !!chain.child && !!chain.dir;

  if(!hasChild){
    seg.startMin = clamp(seg.startMin, 0, 1440-minGap);
    seg.endMin   = clamp(seg.endMin, seg.startMin + minGap, 1440);
    return;
  }

  const p=chain.parent, c=chain.child;
  if(chain.dir==='next'){ p.endMin=1440; c.startMin=0; }
  if(chain.dir==='prev'){ p.startMin=0;  c.endMin=1440; }

  const other = otherSeg(which);
  const otherDur = other ? (other.endMin - other.startMin) : 0;
  const maxThis = 1440 - Math.max(minGap, otherDur);

  if(which==='parent'){
    p.startMin = clamp(p.startMin, 0, 1440-minGap);
    p.endMin   = clamp(p.endMin,   p.startMin + minGap, 1440);
    p.endMin   = Math.min(p.endMin, p.startMin + maxThis);
  }else{
    c.startMin = clamp(c.startMin, 0, 1440-minGap);
    c.endMin   = clamp(c.endMin,   c.startMin + minGap, 1440);
    c.endMin   = Math.min(c.endMin, c.startMin + maxThis);
  }
}

function startDrag(ev, kind, which){
  if(!chain) return;
  const seg = (which==='parent'? chain.parent : chain.child); if(!seg) return;

  ev.preventDefault(); ev.stopPropagation(); ev.currentTarget.setPointerCapture(ev.pointerId);

  dragKind = kind; dragTarget = which;
  dragStartY = ev.clientY; baseStart = seg.startMin; baseEnd = seg.endMin;
  const other = otherSeg(which);
  if(other){ baseOtherStart = other.startMin; baseOtherEnd = other.endMin; otherDurAtStart = baseOtherEnd - baseOtherStart; }
  else { baseOtherStart = 0; baseOtherEnd = 0; otherDurAtStart = 0; }

  crossedTop=crossedBottom=false; lastEdgeCrossed=null;
  wasDrag=false; dragPixels=0;

  const move=(e)=>{
    const dyPx = e.clientY - dragStartY;
    dragPixels = Math.max(dragPixels, Math.abs(dyPx));
    if(dragPixels > 6) wasDrag=true;

    const deltaMinRaw = (weekGeom.totalH? (dyPx / weekGeom.totalH) * 1440 : 0);
    const snappedDelta = snap15(deltaMinRaw);

    if(dragKind==='top'){ seg.startMin = clamp(baseStart + snappedDelta, 0, baseEnd - 15); }
    else { seg.endMin = clamp(baseEnd + snappedDelta, baseStart + 15, 1440); }

    clampToBudget(seg, which);

    if(!chain.child){
      if(seg.startMin===0){ crossedTop=true; lastEdgeCrossed='prev'; }
      if(seg.endMin===1440){ crossedBottom=true; lastEdgeCrossed='next'; }
    }

    drawSelection();
  };

  const up=async (e)=>{
    seg.startMin = snap15(seg.startMin); seg.endMin = snap15(seg.endMin);
    if(seg.endMin - seg.startMin < 15){
      if(dragKind==='top'){ seg.startMin = seg.endMin - 15; }
      else { seg.endMin = seg.startMin + 15; }
    }

    if(!chain.child && wasDrag){
      const want = lastEdgeCrossed || (crossedTop? 'prev' : (crossedBottom? 'next' : null));
      if(want) await spilloverConfirm(want);
    }

    await saveChain(chain).catch(()=>{});
    e.currentTarget.releasePointerCapture(e.pointerId);
    window.removeEventListener('pointermove', move);
    window.removeEventListener('pointerup', up);
    dragKind=null;
  };

  window.addEventListener('pointermove', move, {passive:false});
  window.addEventListener('pointerup', up, {passive:true});
}

/* Single confirm modal */
async function spilloverConfirm(direction){
  if(_modalOpen) return;
  _modalOpen=true;
  const res = await modalConfirm(direction==='prev' ? 'Spill to previous day?' : 'Spill to next day?');
  _modalOpen=false;
  if(!res) return;
  await confirmSpill(direction);
}

function modalConfirm(text){
  return new Promise((resolve)=>{
    const veil=document.createElement('div'); veil.className='veil';
    const modal=document.createElement('div'); modal.className='modal';
    modal.innerHTML=`<div class="head">${text}</div><div class="settings-wrap" style="padding:16px"></div><div class="foot"><button class="btn" data-a="no">Cancel</button><button class="btn ok" data-a="yes">OK</button></div>`;
    document.body.appendChild(veil); document.body.appendChild(modal);
    const close=(val)=>{ veil.remove(); modal.remove(); resolve(val); };
    modal.addEventListener('click', e=>{ const b=e.target.closest('button'); if(!b) return;
      b.dataset.a==='yes'? close(true):close(false);
    });
    veil.addEventListener('click', ()=>close(false));
  });
}

async function confirmSpill(direction){
  if(!chain || !chain.parent) return;

  const p = chain.parent;
  let childWeek = p.weekSt;
  let childDay  = p.dayIdx;

  chain.dir = direction;

  if(direction==='next'){
    if(p.dayIdx < 6){ childDay  = p.dayIdx + 1; childWeek = p.weekSt; }
    else { childDay  = 0; childWeek = p.weekSt + 7*DAY_MS; }
    const rem = clamp(60, 15, 1440 - totalDur(p));
    chain.child = { weekSt: childWeek, dayIdx: childDay, startMin:0, endMin:rem };
    p.endMin = 1440;
    if(p.dayIdx === 6){ visibleWeekFirst = stampToDate(childWeek); }
  }else{
    if(p.dayIdx > 0){ childDay  = p.dayIdx - 1; childWeek = p.weekSt; }
    else { childDay  = 6; childWeek = p.weekSt - 7*DAY_MS; }
    const rem = clamp(60, 15, 1440 - totalDur(p));
    chain.child = { weekSt: childWeek, dayIdx: childDay, startMin:1440 - rem, endMin:1440 };
    p.startMin = 0;
    if(p.dayIdx === 0){ visibleWeekFirst = stampToDate(childWeek); }
  }

  sanitizeChain();
  await saveChain(chain);
  repaintWeek(true); drawSelection();
}

/* anchors to day edges */
function sanitizeChain(){
  if(!chain || !chain.child) return;
  const p=chain.parent, c=chain.child;
  if(chain.dir==='next'){ p.endMin=1440; c.startMin=0; }
  if(chain.dir==='prev'){ p.startMin=0; c.endMin=1440; }
}

/* month & day views (unchanged) */
function buildMonthView(){
  const base = new Date(); activeDayISO = toISO(base);
  const first = new Date(base.getFullYear(), base.getMonth(), 1);
  const label = first.toLocaleDateString(undefined,{month:'long', year:'numeric'});

  screenEl.innerHTML = `
    <div class="month-wrap">
      <div class="head">
        <button id="prevMon" class="neu-btn--sm" aria-label="Prev month" title="Prev">
          <svg viewBox="0 0 24 24" aria-hidden="true"><polyline points="15,5 8,12 15,19"/></svg>
        </button>
        <div class="title">${label}</div>
        <button id="nextMon" class="neu-btn--sm" aria-label="Next month" title="Next">
          <svg viewBox="0 0 24 24" aria-hidden="true"><polyline points="9,5 16,12 9,19"/></svg>
        </button>
      </div>
      <div class="month-dow" aria-hidden="false">
        <span>S</span><span>M</span><span>T</span><span>W</span><span>T</span><span>F</span><span>S</span>
      </div>
      <div class="month-grid" id="monthGrid"></div>
    </div>
  `;

  const prev=document.getElementById('prevMon');
  const next=document.getElementById('nextMon');
  prev.onclick=()=>{ pressFlash(prev); renderMonth(base, -1); unpressFlash(prev); };
  next.onclick=()=>{ pressFlash(next); renderMonth(base, +1); unpressFlash(next); };

  renderMonth(base, 0);

  destroySelButtons(); destroyOverlay();
}

function renderMonth(base, delta){
  const d = new Date(base.getFullYear(), base.getMonth()+delta, 1);
  const first = new Date(d.getFullYear(), d.getMonth(), 1);
  const last  = new Date(d.getFullYear(), d.getMonth()+1, 0);
  document.querySelector('.head .title').textContent =
    first.toLocaleDateString(undefined,{month:'long',year:'numeric'});
  const g=document.getElementById('monthGrid'); g.innerHTML='';

  const firstWeekday = first.getDay();
  const prevLast = new Date(d.getFullYear(), d.getMonth(), 0).getDate();

  for(let i=firstWeekday-1;i>=0;i--){
    const el=document.createElement('div'); el.className='mcell muted';
    el.innerHTML = `<span class="date">${prevLast - i}</span>`;
    g.appendChild(el);
  }
  const todayISO = toISO(new Date());
  for(let day=1; day<=last.getDate(); day++){
    const tile=document.createElement('div');
    tile.className='mcell';
    const iso = toISO(new Date(d.getFullYear(), d.getMonth(), day));
    if(iso===todayISO) tile.classList.add('today');
    tile.innerHTML = `<span class="date">${day}</span>`;
    g.appendChild(tile);
  }
  const used = firstWeekday + last.getDate();
  const rem = (Math.ceil(used/7)*7) - used;
  for(let i=1;i<=rem;i++){
    const el=document.createElement('div'); el.className='mcell muted';
    el.innerHTML = `<span class="date">${i}</span>`;
    g.appendChild(el);
  }
}

function buildDayView(){
  screenEl.innerHTML = `
    <div class="wrap">
      <div class="head"><div></div><div class="title">Day</div><div></div></div>
      <div class="grid-area" style="display:grid;place-items:center;color:#666">
        <div class="watermark">Chrono r70</div>
      </div>
    </div>
  `;
  destroySelButtons(); destroyOverlay();
}

/* init */
function snapshotState(){ return { activeView, activeDayISO, visibleWeekFirst:+visibleWeekFirst }; }
async function saveAll(){ await storageSet('state', snapshotState()); await saveChain(chain); }
let saveTimer=null;
function saveSoon(ms=300){ clearTimeout(saveTimer); saveTimer=setTimeout(()=>{ saveAll().catch(()=>{}); }, ms); }

async function init(){
  try{
    const snap = await storageGet('state');
    if(snap && typeof snap==='object'){
      if('activeView' in snap) activeView = snap.activeView ?? null;
      if('activeDayISO' in snap) activeDayISO = snap.activeDayISO;
      if('visibleWeekFirst' in snap && typeof snap.visibleWeekFirst==='number') visibleWeekFirst = new Date(snap.visibleWeekFirst);
      if(activeView){
        const btn = document.querySelector(`.neu-btn[data-view="${activeView}"]`);
        btn?.classList.add('is-pressed'); btn?.setAttribute('aria-pressed','true');
      }
    }
  }catch{}
  render();
  document.addEventListener('visibilitychange', ()=>{ if(document.visibilityState==='hidden') saveAll().catch(()=>{}); });
  window.addEventListener('beforeunload', ()=>{ saveAll().catch(()=>{}); });
}

function render(){
  if(activeView==='week'){
    buildWeekView();
  } else if(activeView==='day'){
    activeDayISO = toISO(new Date());
    buildDayView();
  } else if(activeView==='month'){
    activeDayISO = toISO(new Date());
    buildMonthView();
  } else {
    screenEl.innerHTML='';
    destroySelButtons(); destroyOverlay();
  }
}
init();

/* utils */
function throttle(fn, ms){
  let t=0, lastArgs=null;
  return function(...args){
    lastArgs=args;
    if(!t){ t=setTimeout(()=>{ t=0; fn.apply(null,lastArgs); }, ms); }
  }
}

/* Side cluster plumbing */
function ensureSelButtons(){
  if(activeView!=='week') { destroySelButtons(); return; }
  if(window.__selBtns && document.body.contains(window.__selBtns)) return;

  const wrap = document.createElement('div');
  wrap.className='selBtns'; wrap.id='selBtns';

  const gear = document.createElement('button');
  gear.className='neu-btn--sm'; gear.setAttribute('aria-label', 'Settings');
  gear.innerHTML = `<svg viewBox="0 0 24 24" aria-hidden="true">
    <circle cx="12" cy="12" r="3.5" />
    <path d="M12 2v3M12 19v3M4.9 4.9l2.1 2.1M17 17l2.1 2.1M2 12h3M19 12h3M4.9 19.1 7 17M17 7l2.1-2.1" />
  </svg>`;
  gear.querySelectorAll('circle,path').forEach(n=>{ n.setAttribute('fill','none'); n.setAttribute('stroke','currentColor'); n.setAttribute('stroke-width','1.35'); n.setAttribute('stroke-linecap','round'); n.setAttribute('stroke-linejoin','round'); });
  gear.addEventListener('click', onGearTap, {passive:true});
  gear.addEventListener('pointerdown', ev=>{ ev.stopPropagation(); }, {capture:true});

  const close = document.createElement('button');
  close.className='neu-btn--sm'; close.setAttribute('aria-label', 'Clear selection');
  close.innerHTML = `<svg viewBox="0 0 24 24" aria-hidden="true"><path d="M6 6l12 12M18 6L6 18" fill="none" stroke="currentColor" stroke-width="1.6" stroke-linecap="round"/></svg>`;
  close.addEventListener('click', onXTap, {passive:true});
  close.addEventListener('pointerdown', ev=>{ ev.stopPropagation(); }, {capture:true});

  wrap.appendChild(gear); wrap.appendChild(close);
  document.body.appendChild(wrap);
  window.__selBtns = wrap;
}
function destroySelButtons(){ if(window.__selBtns){ window.__selBtns.remove(); window.__selBtns=null; } }

function positionSelButtons({left, top}){
  const wrap = window.__selBtns; if(!wrap) return;
  wrap.style.left = `${Math.round(left)}px`;
  wrap.style.top  = `${Math.round(top)}px`;
}

function repositionSelButtons(){
  if(!chain || !weekGeom || !window.__selBtns) return;

  const inWeek=[];
  if(segOnThisWeek(chain.parent)) inWeek.push(boundsFromSeg(chain.parent));
  if(segOnThisWeek(chain.child))  inWeek.push(boundsFromSeg(chain.child));
  if(!inWeek.length){ destroySelButtons(); return; }

  const topMin = Math.min(...inWeek.map(b=>b.topY));
  const botMax = Math.max(...inWeek.map(b=>b.botY));

  const vpCenter = (window.scrollY + window.innerHeight/2) - weekGeom.rect.top;
  let anchor=inWeek[0]; let best=Math.abs(((anchor.topY+b.anchor?.botY)/2 || 0) - vpCenter);
  for(const b of inWeek){ const mid=(b.topY+b.botY)/2, d=Math.abs(mid - vpCenter); if(d<best){best=d; anchor=b;} }

  const margin=8, btnW=44, totalH=(44*2)+8;
  let left = weekGeom.rect.left + anchor.offsetLeft + anchor.colWidth + margin;
  if(left + btnW > window.innerWidth - margin){
    left = Math.max(margin, weekGeom.rect.left + anchor.offsetLeft - margin - btnW);
  }
  let top  = weekGeom.rect.top + topMin + ((botMax-topMin)/2) - (totalH/2);
  if(top + totalH > window.innerHeight - margin){
    top = Math.max(margin, window.innerHeight - margin - totalH);
  }
  if(top < margin) top = margin;

  positionSelButtons({left, top});
}

/* ===== Settings & Stats (Neumorphic) ===== */

function onGearTap(ev){
  ev.stopPropagation();
  openSettingsModal();
}

function openSettingsModal(){
  if(!chain){ return; }

  const veil = document.createElement('div'); veil.className='veil';
  const modal = document.createElement('div'); modal.className='modal';

  const parent = chain.parent;
  const startDay = new Date(parent.weekSt + parent.dayIdx*DAY_MS);
  const startDow = SHORT_DOW[startDay.getDay()];

  const defaults = {
    activityKey: null, // none selected until user picks (placeholder mode)
    colorHex: null,
    note: '',
    fromMin: parent?.startMin ?? 480,
    toMin: parent?.endMin ?? 540,
    recurrence: 'reoccurring', // 'reoccurring' | 'week' | 'month'
    flexibility: 'flexible',   // default until activity chosen; will update after pick
    notify: 'reoccurring',     // 'reoccurring' | 'week' | 'month' | 'off'
    privacy: 'private'         // 'private' | 'visible'
  };

  modal.innerHTML = `
    <div class="head">Settings</div>
    <div class="settings-wrap" id="settingsWrap">
      <!-- Assign Activity -->
      <div class="neu-field" id="assignField">
        <div class="neu-select" id="assignSelect" role="button" aria-expanded="false">
          <span class="ph" id="assignLabel">Assign Activity</span>
          <svg viewBox="0 0 24 24" aria-hidden="true"><polyline points="6,9 12,15 18,9"/></svg>
        </div>
        <div class="neu-menu" id="assignMenu">
          <div class="menu-card" id="assignList"></div>
        </div>
        <div class="row" id="selectedChipRow" style="display:none">
          <span class="chip" id="actChip">
            <span class="dot" id="actDot"></span>
            <span id="actName"></span>
            <button class="edit" id="renameBtn" title="Rename">
              <svg viewBox="0 0 24 24"><path d="M4 20h4l10-10-4-4L4 16v4zM14 6l4 4"/></svg>
            </button>
          </span>
        </div>
        <div class="note-field" id="noteRow" style="display:none">
          <input class="note-input" id="noteInput" maxlength="80" placeholder="Add a note (e.g., Walk the dog, Bank run)" />
        </div>
      </div>

      <!-- Time (AM/PM with day initials; picker-only) -->
      <div class="neu-field">
        <div class="time-row">
          <div class="time-pair">
            <span class="time-day" id="fromDay">${startDow}</span>
            <button class="time-btn" id="fromBtn" type="button">${HHMM_ampm(defaults.fromMin)}</button>
          </div>
          <div class="time-pair">
            <span class="time-day" id="toDay">${startDow}</span>
            <button class="time-btn" id="toBtn" type="button">${HHMM_ampm(defaults.toMin)}</button>
          </div>
        </div>
        <!-- hidden inputs to trigger native pickers; keyboard input suppressed -->
        <input id="fromPicker" type="time" step="900" style="position:absolute;opacity:0;width:0;height:0;border:0;padding:0" />
        <input id="toPicker"   type="time" step="900" style="position:absolute;opacity:0;width:0;height:0;border:0;padding:0" />
      </div>

      <!-- Options -->
      <div class="neu-field">
        <div class="row4">
          <div class="neu-select" id="recurringSel"><span>Reoccurring</span><svg viewBox="0 0 24 24"><polyline points="6,9 12,15 18,9"/></svg></div>
          <div class="neu-menu" id="recurringMenu"><div class="menu-card">
            <div class="menu-item" data-val="reoccurring">Reoccurring</div>
            <div class="menu-item" data-val="week">This week</div>
            <div class="menu-item" data-val="month">This month</div>
          </div></div>

          <div class="neu-select" id="flexSel"><span>Flexible</span><svg viewBox="0 0 24 24"><polyline points="6,9 12,15 18,9"/></svg></div>
          <div class="neu-menu" id="flexMenu"><div class="menu-card">
            <div class="menu-item" data-val="flexible">Flexible</div>
            <div class="menu-item" data-val="firm">Firm</div>
          </div></div>

          <div class="neu-select" id="notifSel"><span>Notifications</span><svg viewBox="0 0 24 24"><polyline points="6,9 12,15 18,9"/></svg></div>
          <div class="neu-menu" id="notifMenu"><div class="menu-card">
            <div class="menu-item" data-val="reoccurring">Reoccurring</div>
            <div class="menu-item" data-val="week">This week</div>
            <div class="menu-item" data-val="month">This month</div>
            <div class="menu-item" data-val="off">Off</div>
          </div></div>

          <div class="neu-select" id="privacySel"><span>Private</span><svg viewBox="0 0 24 24"><polyline points="6,9 12,15 18,9"/></svg></div>
          <div class="neu-menu" id="privacyMenu"><div class="menu-card">
            <div class="menu-item" data-val="private">Private</div>
            <div class="menu-item" data-val="visible">Visible to connected accounts</div>
          </div></div>
        </div>
      </div>

      <!-- Statistics button -->
      <div class="row">
        <button class="btn" id="statsBtn">Statistics</button>
      </div>

      <!-- Color palette editor (opens from chip edit) -->
      <div class="neu-field" id="colorField" style="display:none">
        <div class="label">Choose Color</div>
        <div class="swatch-grid" id="swatchGrid"></div>
      </div>
    </div>

    <div class="foot">
      <button class="btn" id="exitBtn">Exit</button>
      <button class="btn ok" id="saveBtn">Save</button>
    </div>
  `;

  document.body.appendChild(veil); document.body.appendChild(modal);

  const closeAll = ()=>{ veil.remove(); modal.remove(); };
  veil.addEventListener('click', ()=>{ confirmExit(closeAll); });

  // Build activity list menu
  const listEl = modal.querySelector('#assignList');
  ACTIVITY_LIST.forEach(a=>{
    const row = document.createElement('div'); row.className='menu-item'; row.dataset.key=a.key;
    const dot = document.createElement('span'); dot.className='menu-dot'; dot.style.background = colorForActivity(a.key);
    const label = document.createElement('span'); label.textContent = a.label;
    row.appendChild(dot); row.appendChild(label);
    row.addEventListener('click', ()=>{
      defaults.activityKey = a.key;
      defaults.colorHex = colorForActivity(a.key);
      defaults.flexibility = defaultFlexForActivity(a.key);
      modal.querySelector('#assignLabel').textContent = a.label;
      modal.querySelector('#assignMenu').classList.remove('open');
      modal.querySelector('#assignSelect').setAttribute('aria-expanded','false');
      // reveal chip + note
      modal.querySelector('#selectedChipRow').style.display = '';
      modal.querySelector('#noteRow').style.display = '';
      const chipDot = modal.querySelector('#actDot'); chipDot.style.background = defaults.colorHex;
      modal.querySelector('#actName').textContent = a.label;
      // reflect default flex in control
      modal.querySelector('#flexSel span').textContent = (defaults.flexibility==='firm'?'Firm':'Flexible');
    });
    listEl.appendChild(row);
  });

  modal.querySelector('#assignSelect').addEventListener('click', ()=>{
    const m = modal.querySelector('#assignMenu');
    const open = m.classList.toggle('open');
    modal.querySelector('#assignSelect').setAttribute('aria-expanded', open?'true':'false');
  });

  // Rename & color edit
  modal.querySelector('#renameBtn').addEventListener('click', ()=>{
    const nameEl = modal.querySelector('#actName');
    const next = prompt('Rename activity (max 14 chars):', nameEl.textContent)?.slice(0,14);
    if(next && next.trim().length){ nameEl.textContent = next.trim(); }
    // show color palette for this activity
    buildSwatches();
    modal.querySelector('#colorField').style.display='';
  });

  function buildSwatches(){
    const grid = modal.querySelector('#swatchGrid'); grid.innerHTML='';
    COLOR_SWATCHES.forEach((hex, idx)=>{
      const sw = document.createElement('div'); sw.className='sw'; sw.style.background=hex;
      if(hex===defaults.colorHex) sw.classList.add('sel');
      sw.addEventListener('click', ()=>{
        defaults.colorHex = hex;
        grid.querySelectorAll('.sw').forEach(x=>x.classList.remove('sel'));
        sw.classList.add('sel');
        modal.querySelector('#actDot').style.background = hex;
      });
      grid.appendChild(sw);
    });
  }

  // Dropdown helpers
  hookMenu(modal, '#recurringSel','#recurringMenu', (val,label)=>{ defaults.recurrence=val; modal.querySelector('#recurringSel span').textContent=label; });
  hookMenu(modal, '#flexSel','#flexMenu', (val,label)=>{ defaults.flexibility=val; modal.querySelector('#flexSel span').textContent=label; });
  hookMenu(modal, '#notifSel','#notifMenu', (val,label)=>{ defaults.notify=val; modal.querySelector('#notifSel span').textContent=label; });
  hookMenu(modal, '#privacySel','#privacyMenu', (val,label)=>{ defaults.privacy=val; modal.querySelector('#privacySel span').textContent=label; });

  // Time pickers (AM/PM, 15-min, <=24h consecutive)
  const fromBtn = modal.querySelector('#fromBtn');
  const toBtn   = modal.querySelector('#toBtn');
  const fromPk  = modal.querySelector('#fromPicker');
  const toPk    = modal.querySelector('#toPicker');
  // prevent typing
  fromPk.addEventListener('keydown', e=>e.preventDefault());
  toPk.addEventListener('keydown', e=>e.preventDefault());

  function setPickerValue(input, minutes){
    const h = Math.floor(minutes/60), m = minutes%60;
    input.value = `${String(h).padStart(2,'0')}:${String(m).padStart(2,'0')}`;
  }
  setPickerValue(fromPk, defaults.fromMin);
  setPickerValue(toPk, defaults.toMin);

  fromBtn.addEventListener('click', ()=>{ fromPk.showPicker?.(); });
  toBtn.addEventListener('click',   ()=>{ toPk.showPicker?.(); });

  fromPk.addEventListener('change', ()=>{
    const [h,m]=fromPk.value.split(':').map(Number);
    const mins = h*60+m;
    defaults.fromMin = snap15(mins);
    // enforce at least +15 and <=24h
    if(defaults.toMin <= defaults.fromMin) defaults.toMin = clamp(defaults.fromMin+15, 0, 24*60);
    fromBtn.textContent = HHMM_ampm(defaults.fromMin);
    updateTimeDays();
    setPickerValue(toPk, defaults.toMin);
  });
  toPk.addEventListener('change', ()=>{
    const [h,m]=toPk.value.split(':').map(Number);
    let mins = h*60+m;
    mins = snap15(mins);
    // Block >24h (same-day only unless we have spillover chain)
    const maxEnd = chain.child ? 1440 : 1440; // still <= 24h window overall
    if(mins <= defaults.fromMin) mins = clamp(defaults.fromMin+15, 0, maxEnd);
    defaults.toMin = mins;
    toBtn.textContent = HHMM_ampm(defaults.toMin);
    updateTimeDays();
  });

  function updateTimeDays(){
    const fromDay = new Date(parent.weekSt + parent.dayIdx*DAY_MS);
    const toBase = new Date(parent.weekSt + parent.dayIdx*DAY_MS);
    let toDay = toBase;
    if(chain.child && defaults.toMin===1440) toDay = addDays(toBase,1);
    modal.querySelector('#fromDay').textContent = SHORT_DOW[fromDay.getDay()];
    modal.querySelector('#toDay').textContent   = SHORT_DOW[toDay.getDay()];
  }
  updateTimeDays();

  // Stats
  modal.querySelector('#statsBtn').addEventListener('click', async ()=>{
    const actLabel = defaults.activityKey ? getActivityByKey(defaults.activityKey).label : '—';
    await openStatsModal(actLabel, defaults.colorHex || '#999');
  });

  // Save / Exit
  modal.querySelector('#exitBtn').addEventListener('click', ()=>{ confirmExit(closeAll); });
  modal.querySelector('#saveBtn').addEventListener('click', async ()=>{
    if(!defaults.activityKey){
      alert('Please assign an activity.');
      return;
    }
    // validate times: consecutive block, <=24h, step 15 ensured by picker
    if(!(defaults.toMin > defaults.fromMin)){
      alert('End time must be after start time.');
      return;
    }
    const note = modal.querySelector('#noteInput').value.trim();
    await finalizeBlock({
      actKey: defaults.activityKey,
      actName: modal.querySelector('#actName').textContent,
      colorHex: defaults.colorHex || colorForActivity(defaults.activityKey),
      from: defaults.fromMin,
      to: defaults.toMin,
      recurVal: defaults.recurrence,
      flexVal: defaults.flexibility,
      notifVal: defaults.notify,
      privVal: defaults.privacy,
      note
    });
    closeAll();
  });
}

function hookMenu(root, selSel, menuSel, onPick){
  const trigger = root.querySelector(selSel);
  const menu = root.querySelector(menuSel);
  trigger.addEventListener('click', ()=>{
    const open = menu.classList.toggle('open');
    trigger.setAttribute('aria-expanded', open?'true':'false');
  });
  menu.querySelectorAll('.menu-item').forEach(mi=>{
    mi.addEventListener('click', ()=>{
      onPick(mi.dataset.val, mi.textContent.trim());
      menu.classList.remove('open');
      trigger.setAttribute('aria-expanded','false');
    });
  });
}

function confirmExit(done){
  const text='Are you sure you want to exit without saving?';
  modalConfirm(text).then(ok=>{
    if(ok) done();
  });
}

/* finalize: save block(s), clear selection, paint colored block(s) */
async function finalizeBlock({actKey, actName, colorHex, from, to, recurVal, flexVal, notifVal, privVal, note}){
  if(!chain || !chain.parent) return;

  // base block for parent segment
  const parent = chain.parent;
  const base = {
    id: 'b'+Date.now(),
    weekSt: parent.weekSt,
    dayIdx: parent.dayIdx,
    startMin: from,
    endMin: to,
    activityKey: actKey,
    activityName: actName,
    colorHex,
    note: note || '',
    recurrence: (recurVal==='reoccurring' ? 'weekly' : (recurVal==='week' ? 'none' : 'monthly')),
    flexibility: flexVal,
    notifications: notifVal,
    privacy: privVal
  };
  await putBlock(base);

  // spillover child handled if present (keeps child minutes as set by selector)
  if(chain.child){
    const child = chain.child;
    const cBlock = {
      ...base,
      id: 'b'+(Date.now()+1),
      weekSt: child.weekSt,
      dayIdx: child.dayIdx,
      startMin: child.startMin,
      endMin: child.endMin
    };
    await putBlock(cBlock);
  }

  // clear selection → leave colored blocks
  chain = null;
  await saveChain(null);
  repaintWeek(true); drawSelection(); drawBlocks();
}

/* Statistics modal */
async function openStatsModal(activityName, color){
  const veil=document.createElement('div'); veil.className='veil';
  const modal=document.createElement('div'); modal.className='modal';
  modal.innerHTML = `
    <div class="head">Statistics — ${activityName}</div>
    <div class="settings-wrap" id="statsWrap">
      <div class="stat-line"><span>Average hours / week</span><span id="avgW">—</span></div>
      <div class="stat-line"><span>Average hours / month</span><span id="avgM">—</span></div>
      <div class="stat-line"><span>Average hours / year</span><span id="avgY">—</span></div>
      <div class="stat-line"><span>Completion</span><span id="pct" class="pct">—</span></div>
    </div>
    <div class="foot">
      <button class="btn ok" id="closeStats">Close</button>
    </div>
  `;
  document.body.appendChild(veil); document.body.appendChild(modal);

  const stats = await computeActivityStats(activityName);
  modal.querySelector('#avgW').textContent = stats.avgWeek.toFixed(2);
  modal.querySelector('#avgM').textContent = stats.avgMonth.toFixed(2);
  modal.querySelector('#avgY').textContent = stats.avgYear.toFixed(2);

  const pct = stats.completionPct;
  const pctEl = modal.querySelector('#pct');
  pctEl.textContent = `${Math.round(pct)}%`;
  pctEl.classList.remove('green','yellow','orange','red');
  pctEl.classList.add(pct>=75?'green':pct>=50?'yellow':pct>=25?'orange':'red');

  modal.querySelector('#closeStats').addEventListener('click', ()=>{ veil.remove(); modal.remove(); });
  veil.addEventListener('click', ()=>{ veil.remove(); modal.remove(); });
}

async function computeActivityStats(activityName){
  const blocks = await getBlocksAll();
  const msNow = Date.now();
  const oneWeek = 7*DAY_MS;
  const oneMonth = 30*DAY_MS;
  const oneYear = 365*DAY_MS;

  function sumHours(rangeMs){
    const from = msNow - rangeMs;
    let minutes=0;
    for(const b of blocks){
      if(b.activityName!==activityName) continue;
      const instances = [];
      if(b.recurrence==='weekly'){
        for(let t=b.weekSt; t<=msNow; t+=oneWeek){ instances.push({...b, weekSt:t}); }
      }else{
        instances.push(b);
      }
      for(const inst of instances){
        const weekTime = inst.weekSt + inst.dayIdx*DAY_MS;
        if(weekTime >= from && weekTime <= msNow){
          minutes += (inst.endMin - inst.startMin);
        }
      }
    }
    return minutes/60;
  }

  const weekH = sumHours(oneWeek);
  const monthH = sumHours(oneMonth);
  const yearH = sumHours(oneYear);

  const completionPct = 100; // placeholder until completion tracking exists

  return { avgWeek: weekH, avgMonth: monthH, avgYear: yearH, completionPct };
}

/* Clear selection */
async function onXTap(ev){
  ev.stopPropagation();
  if(!chain) return;
  chain = null;
  await saveChain(null).catch(()=>{});
  document.getElementById('selHost')?.replaceChildren();
  destroySelButtons();
  overlayRoot && (overlayRoot.innerHTML='');
}

/* viewport listeners once */
let _vpAttached=false;
function attachViewportRepositioners(){
  if(_vpAttached) return;
  _vpAttached=true;
  const handler = throttle(()=>{ repositionSelButtons(); }, 16);
  window.addEventListener('scroll', handler, {passive:true});
  window.addEventListener('resize', handler, {passive:true});
  window.addEventListener('orientationchange', handler, {passive:true});
  if(window.visualViewport) window.visualViewport.addEventListener('resize', handler, {passive:true});
}
</script>

<!-- Service worker registration -->
<script>
if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('./service-worker.js')
      .then(reg => console.log('SW registered', reg.scope))
      .catch(err => console.error('SW registration failed', err));
  });
}
</script>

</body>
</html>

